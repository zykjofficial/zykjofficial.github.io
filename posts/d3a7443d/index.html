<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaScript学习 | 卓越科技的Blog</title><meta name="keywords" content="JavaScript"><meta name="author" content="卓越科技-"><meta name="copyright" content="卓越科技-"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="这篇文章主要是讲JavaScript学习有关的知识、资料来自于网络。"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript学习"><meta property="og:url" content="https://blog.zykjofficial.top/posts/d3a7443d/index.html"><meta property="og:site_name" content="卓越科技的Blog"><meta property="og:description" content="这篇文章主要是讲JavaScript学习有关的知识、资料来自于网络。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/javascriptstudy-cover.png"><meta property="article:published_time" content="2020-04-29T13:38:11.000Z"><meta property="article:modified_time" content="2020-07-29T13:38:11.000Z"><meta property="article:author" content="卓越科技-"><meta property="article:tag" content="JavaScript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/javascriptstudy-cover.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.zykjofficial.top/posts/d3a7443d/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media=&quot;all&quot;,this.onload=null"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css" media="print" onload="this.media=&quot;all&quot;,this.onload=null"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2020-07-29 21:38:11"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="卓越科技的Blog" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div></div></div><hr></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/javascriptstudy-cover.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">卓越科技的Blog</a></span><span id="menus"><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">JavaScript学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-29T13:38:11.000Z" title="发表于 2020-04-29 21:38:11">2020-04-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-07-29T13:38:11.000Z" title="更新于 2020-07-29 21:38:11">2020-07-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Web%E6%95%99%E7%A8%8B/">Web教程</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Web%E6%95%99%E7%A8%8B/JavaScript/">JavaScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h2><div class="note danger flat"><p>本教程里的资料来源于网友的资料，自己整理以供学习。视频学习: <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/BV1ux411d75J">黑马程序员</a></p></div><h3 id="JS概论"><a href="#JS概论" class="headerlink" title="JS概论"></a>JS概论</h3><ul><li><p>HTML/CSS - <code>标记语言</code></p></li><li><p>JS脚本语言 - <code>编程类语言</code></p></li></ul><blockquote><p>浏览器分成两部分,<code>渲染引擎</code>和<code>JS引擎</code></p></blockquote><ul><li>渲染引擎:用来解析 HTML 与 CSS,俗称内核,比如 Chrome 的 blink</li></ul><blockquote><p>JS引擎: JS解释器,用来读取网页中的 JavaScript 代码,对其处理后运行,比如 chrome 浏览器的 V8</p></blockquote><ul><li><p>浏览器本身并不会执行 JS 代码,而是通过内置 JavaScript 引擎来执行 JS 代码, JS 引擎执行代码时逐行解释每一句源码(转换为机器语言二进制),然后由计算机去执行</p></li><li><p><code>解释性语言: 进行时立即解释执行的语言 如 Js</code></p></li><li><p><code>编译性语言: 必须通过编译生成中间代码后才执行的语言 如 Java、C</code></p></li></ul><blockquote><p>JS组成: ECMAscript(js语法)、DOM(页面文档对象模型)、BOM(浏览器对象模型)后两者即合称 API</p></blockquote><ul><li>ECMAscript: 规定了JS的编程语法和基础核心知识,是所有浏览器厂商共同遵守的一套 JS 语法工业标准</li></ul><blockquote><p>JavaScript程序的执行</p></blockquote><ul><li>出现在<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>标记对之间的 javascript 语句按照它们在脚本中出现的顺序来执行。当一个文件有多个脚本的时候,脚本按照它们出现的顺序来执行(除非脚本带有 defer 属性)。<code>&lt;script&gt;</code>标记中的 JS 代码作为文档载入和解析过程的一部分来执行</li></ul><h3 id="JS词法结构"><a href="#JS词法结构" class="headerlink" title="JS词法结构"></a>JS词法结构</h3><h4 id="JS注释"><a href="#JS注释" class="headerlink" title="JS注释"></a>JS注释</h4><ul><li><p>单行注释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一行都是注释内容</span></span><br></pre></td></tr></table></figure></li><li><p>多行注释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 这里面的内容为注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>快捷键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释 ctrl+&#x2F; </span><br><span class="line"></span><br><span class="line">多行注释 ctrl+shift+&#x2F;</span><br></pre></td></tr></table></figure></li></ul><h4 id="JS相关"><a href="#JS相关" class="headerlink" title="JS相关"></a>JS相关</h4><p>标识符、关键字、保留字、直接量</p><ul><li><p><code>标识符</code>: 开发人员为<code>变量</code>、<code>属性</code>、<code>函数</code>、<code>参数</code>取的名字(标识符不能是关键字或保留字)</p></li><li><p><code>关键字</code>: js 本身已经使用了的字</p></li><li><p><code>保留字</code>: 为后面预留的关键字 如 <code>boolean</code> <code>byte</code> <code>char</code> <code>int</code> 等</p></li><li><p><code>字面量(直接量)</code>:程序中直接显示出来的数据值</p></li><li><p><code>数字字面量</code>: 8、9、10</p></li><li><p><code>字符串字面量</code>: “大前端”</p></li><li><p><code>布尔字面量</code>: true false</p></li></ul><h4 id="JS命名规则"><a href="#JS命名规则" class="headerlink" title="JS命名规则"></a>JS命名规则</h4><div class="note info flat"><p>标识符命名规则</p></div><ul><li><p>必须要有意义</p></li><li><p>变量一般用名词</p></li><li><p>函数一般用动词</p></li><li><p>不能与其他关键字同名</p></li></ul><div class="note info flat"><p>操作符规范</p></div><ul><li><p>操作符左右两侧各保留个空格</p></li><li><p>单行注释//后加一个空格再写注释</p></li><li><p>末尾大括号要对齐其父元素</p></li></ul><h3 id="JS嵌入HTML"><a href="#JS嵌入HTML" class="headerlink" title="JS嵌入HTML"></a>JS嵌入HTML</h3><h4 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h4><blockquote><p>放置在 HTML 事件处理程序中</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Hello World!&#x27;)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><input type="button" value="点我" onclick='alert("Hello World!")'><p>注意:</p><ul><li><p>可以将单行或少量JS代码写在HTML标签的事件属性中(以 on 开头的属性),如: onclick</p></li><li><p>注意单双引号的使用: 在 HTML 中我们推荐使用双引号,JS 中使用单引号</p></li><li><p>可读性差</p></li><li><p>引号易错,易混淆</p></li><li><p>特殊情况下使用</p></li></ul><h4 id="内联式"><a href="#内联式" class="headerlink" title="内联式"></a>内联式</h4><blockquote><p>直接写在 html 文件中,一般写在 body 标签中所有元素后面</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>     </span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;Hello World!&#x27;</span>); </span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="外联式"><a href="#外联式" class="headerlink" title="外联式"></a>外联式</h4><blockquote><p>放置在由标签的 src 属性指定的外部 js 文件中</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;my.js&quot;</span>&gt;</span>此处不可写代码<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>引用外部 js 文件的 script 标签中间不可以写代码</li><li>执行顺序就是他们在文档中出现的顺序</li></ul><h4 id="指定脚本语言"><a href="#指定脚本语言" class="headerlink" title="指定脚本语言"></a>指定脚本语言</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Script-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般浏览器会假设 js 为默认脚本化语言,如果没有指定默认语言,或者想覆盖默认语言,可以使用<code>type属性</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="script标记的属性"><a href="#script标记的属性" class="headerlink" title="script标记的属性"></a>script标记的属性</h4><blockquote><p>defer、async<br>脚本的执行在默认情况下是同步和阻塞的。但是如果有了属性 defer 或者 async,情况会发生变化。</p></blockquote><ul><li><p><code>defer作用</code>: 浏览器解析遇到带有 defer 属性的 script 标记时,延迟该脚本的执行。文档的载入和解析完成再继续执行</p></li><li><p><code>async作用</code>: 浏览器可以尽快执行脚本,不用在下载脚本时阻塞文档解析。即一边下载 js 一边解析文档,js</p></li><li><p>如果两者同时都有,那么会遵从 async 而忽略 defer</p></li></ul><h3 id="JS输入输出语句"><a href="#JS输入输出语句" class="headerlink" title="JS输入输出语句"></a>JS输入输出语句</h3><ul><li><p><code>alert(msg)</code>: 浏览器弹出警示框</p></li><li><p><code>console.log(msg)</code>: 浏览器控制台打印输出信息</p></li><li><p><code>prompt(info)</code>: 浏览器弹出输入框,用户可以输入,输入的是字符串</p></li><li><p><code>confirm(msg)</code>: 浏览器弹出确认框,点击确认返回 true,否则返回 false</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个输入框 		</span></span><br><span class="line">prompt(<span class="string">&#x27;请输入您的年龄&#x27;</span>); 		</span><br><span class="line"><span class="comment">// 弹出警示框 输出展示给用户的 		</span></span><br><span class="line">alert(<span class="string">&#x27;输入结果是: &#x27;</span>); 		</span><br><span class="line"><span class="comment">// console 控制台输出 便于测试 		</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我是程序猿&#x27;</span>);           </span><br><span class="line"><span class="comment">//弹出确认框           </span></span><br><span class="line"><span class="keyword">var</span> right = confirm(<span class="string">&quot;你确定吗?&quot;</span>); <span class="comment">// right 结果为真说明点击了确定</span></span><br></pre></td></tr></table></figure><p>注意: confirm、prompt、alert <code>都会产生阻塞</code>,但他们弹出时,代码会停止运行。</p><h3 id="JS变量"><a href="#JS变量" class="headerlink" title="JS变量"></a>JS变量</h3><h4 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h4><h5 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明变量(var=variable)</span></span><br><span class="line"><span class="keyword">var</span> age; <span class="comment">//声明一个名为age的变量</span></span><br></pre></td></tr></table></figure><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// = 表示把右边的值赋予左边的值</span></span><br><span class="line">age = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h5 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><h5 id="变量语法扩展"><a href="#变量语法扩展" class="headerlink" title="变量语法扩展"></a>变量语法扩展</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myname=<span class="string">&#x27;卓越科技-&#x27;</span>; 	</span><br><span class="line"><span class="built_in">console</span>.log(myname); <span class="comment">//	卓越科技-</span></span><br><span class="line">myname=<span class="string">&#x27;zykj&#x27;</span>; 	</span><br><span class="line"><span class="built_in">console</span>.log(myname); <span class="comment">// zykj</span></span><br></pre></td></tr></table></figure><p><code>变量值只取就近一个</code></p><h5 id="声明多个变量"><a href="#声明多个变量" class="headerlink" title="声明多个变量"></a>声明多个变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age=<span class="number">18</span>, address=<span class="string">&#x27;火影村&#x27;</span>, gz=<span class="number">2000</span>;</span><br></pre></td></tr></table></figure><h5 id="声明变量的特殊情况"><a href="#声明变量的特殊情况" class="headerlink" title="声明变量的特殊情况"></a>声明变量的特殊情况</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.只声明不赋值 结果为undefined </span></span><br><span class="line"><span class="keyword">var</span> sex; </span><br><span class="line"><span class="built_in">console</span>.log(sex); <span class="comment">//undefined </span></span><br><span class="line"><span class="comment">// 2.不声明不赋值 直接使用某个变量 结果报错 </span></span><br><span class="line"><span class="comment">// console.log(tel); </span></span><br><span class="line"><span class="comment">// 不声明直接赋值 结果正确 不推荐 </span></span><br><span class="line">qq = <span class="number">110</span>; </span><br><span class="line"><span class="built_in">console</span>.log(qq); </span><br></pre></td></tr></table></figure><h4 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h4><ul><li><p>由字母数字下划线美元符号构成,不能有横杠！！！</p></li><li><p>区分大小写</p></li><li><p>不能数字开头</p></li><li><p>不能是关键字、保留字</p></li><li><p>变量名必须有意义</p></li><li><p>遵守驼峰命名法</p></li><li><p>对于内部使用的函数变量可以用下划线开头结尾的格式命名</p></li></ul><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><blockquote><p>变量起作用的范围,可以提高程序的可靠性,减少命名冲突</p></blockquote><h5 id="作用域类型"><a href="#作用域类型" class="headerlink" title="作用域类型"></a>作用域类型</h5><ul><li><p>全局作用域: 整个 script 标签内 或是一个单独的 js 文件</p></li><li><p>局部作用域: 在函数内部,代码名字只在函数内部起效果和作用</p></li></ul><h5 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h5><blockquote><p>根据作用域的不同,变量可分为: 1.全局变量 2.局部变量</p></blockquote><ul><li><p>全局变量: 在全局起作用的变量</p></li><li><p>局部变量: 在局部作用域下的变量(函数内部的变量)函数形参亦可以看做局部变量</p></li></ul><p>从执行效率看</p><ul><li><p>全局变量只有浏览器关闭时才会销毁,比较占内存资源</p></li><li><p>局部变量在程序执行完毕时即销毁</p></li></ul><p>现阶段 js 没有块级作用域(即花括号包含之内): 函数中声明的所有变量,无论是在那里声明在整个函数中都是有定义的,因为变量提升的原因</p><h5 id="全局对象和调用对象"><a href="#全局对象和调用对象" class="headerlink" title="全局对象和调用对象"></a>全局对象和调用对象</h5><ul><li><p><code>全局对象</code>: 当 js 解释器开始运行时,它首先要做的是在执行任何 js 代码前创建一个全局对象,而全局变量就是这个全局对象的属性。在客户端 JS(嵌入网页的JS)中,这个全局对象就是 Window 对象</p></li><li><p><code>调用对象</code>: 每调用一次函数时,会在该函数作用域链前加一个调用对象。函数的参数和局部变量是作为调用对象的属性而存储的。用一个完全独立的对象来存储局部变量使 JS 可以防止局部变量覆盖同名的全局变量的值</p></li></ul><h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><blockquote><p>为一个对象列表或对象链。在一个<code>非嵌套函数中,作用域链由这个函数的调用对象和全局对象组成</code></p></blockquote><ul><li><p>内部函数访问外部函数的变量,采取的是链式查找的方式根据就近原则来决定取那个值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; 	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">20</span>; 		</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123; 			</span><br><span class="line">        <span class="built_in">console</span>.log(num); 		</span><br><span class="line">    &#125; 		</span><br><span class="line">    fun(); 	</span><br><span class="line">&#125; 	</span><br><span class="line">fn(); <span class="comment">// 结果是20</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ul><li><p>JavaScript 每次创建字符串数组或对象时,解释器都必须f分配内存储存实体</p></li><li><p>与C、C++不同,js 有垃圾收集的机制,解释器可以检测何时程序不再使用一个对象,当确定了对象是无用的时候,会自动释放其占用的内存</p></li></ul><h3 id="数据类型-占用内存大小不同"><a href="#数据类型-占用内存大小不同" class="headerlink" title="数据类型(占用内存大小不同)"></a>数据类型(占用内存大小不同)</h3><div class="note info flat"><p>js 是一种弱类型或者说动态语言，不用提前声明变量的类型，在程序运行过程中，类型会自动被确定，js 的变量数据类型只有被赋值后才被确定<br>相同的变量可用于不同的数据类型</p></div><h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><p>三种基本数据类型: <code>数字型</code>、<code>字符串型</code>和<code>布尔型</code></p><p>两种小数据类型: <code>null</code>、<code>undefined</code></p><p>还有ES6新增: <code>symbol</code></p><table><thead><tr><th>简单数据类型</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>number</td><td>数字型,包含整型值和浮点型值,如 21,0.21</td><td>0</td></tr><tr><td>boolean</td><td>布尔型,如true、false</td><td>false</td></tr><tr><td>string</td><td>字符串类型,如”张三”</td><td>“”</td></tr><tr><td>undefined</td><td>var a; 声明但没赋值 此时a = undefined</td><td>undefined</td></tr><tr><td>null</td><td>var a = null; 声明了变量a为空值</td><td>null</td></tr></tbody></table><h4 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><blockquote><p>对象(object)、数组(array)、函数(function)、日期(Date)、正则表达式(RegExp).本质上都是对象</p></blockquote><h4 id="数字型Number"><a href="#数字型Number" class="headerlink" title="数字型Number"></a>数字型Number</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">var</span> PI = <span class="number">3.14</span>; </span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">010</span>;    </span><br><span class="line"><span class="comment">// 数字前面加0,代表八进制 </span></span><br><span class="line"><span class="built_in">console</span>.log(num1);  </span><br><span class="line"><span class="comment">// 数字前面加0x,代表16进制 </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">0x9</span>; </span><br><span class="line"><span class="keyword">var</span> num4 = <span class="number">0xa</span>; </span><br><span class="line"><span class="comment">// 最大值 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE); </span><br><span class="line"><span class="comment">// 最小值 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_VALUE);  </span><br><span class="line"><span class="comment">// 无穷大 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE * <span class="number">2</span>);  <span class="comment">/*输出 Infinity 无穷大*/</span> </span><br><span class="line"><span class="comment">// 无穷小 </span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="built_in">Number</span>.MAX_VALUE * <span class="number">2</span>); <span class="comment">/*输出 -Infinity 无穷小*/</span> </span><br><span class="line"><span class="comment">// 非数值 NaN </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;ab&#x27;</span> - <span class="number">2</span>); <span class="comment">/*输出NaN*/</span></span><br></pre></td></tr></table></figure><ul><li><p><code>isNaN();</code>: 用来判断非数字 数字返回 false 非数字返回 true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">12</span>));  <span class="comment">//结果为false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&#x27;dada&#x27;</span>));  <span class="comment">//结果为true</span></span><br></pre></td></tr></table></figure></li><li><p><code>变量.toFixed(n);</code>: 将变量保留 n 位小数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num =<span class="number">2.312313</span>; </span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">3</span>)); <span class="comment">// 2.312</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="字符串型-不是对象"><a href="#字符串型-不是对象" class="headerlink" title="字符串型(不是对象)"></a>字符串型(不是对象)</h4><ul><li><p>语法:双引号或单引号(推荐)</p></li><li><p>嵌套: 外双内单或者外单内双</p></li></ul><p>转义符(以\开头)</p><table><thead><tr><th>转义符</th><th>解释说明</th></tr></thead><tbody><tr><td><code>\n</code></td><td>换行符,n 是 newline 的意思</td></tr><tr><td><code>\\</code></td><td>斜杠 \</td></tr><tr><td><code>\&#39;</code></td><td>‘ 单引号</td></tr><tr><td><code>\*</code></td><td>“ 双引号</td></tr><tr><td><code>\t</code></td><td>tab 缩进</td></tr><tr><td><code>\b</code></td><td>空格,b 是 blank 的意思</td></tr></tbody></table><h5 id="字符串的length属性"><a href="#字符串的length属性" class="headerlink" title="字符串的length属性"></a>字符串的length属性</h5><p>用于检测字符串长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测获取字符串的长度 	</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;my name is zykj&#x27;</span>; 	</span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><h5 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h5><p>多个字符串之间可以用+拼接,拼接方式为字符串+任何类型=拼接之后的新字符串</p><p>数值型和字符型之间也可以相加</p><p>口诀: <code>数值相加,字符相连</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span> + <span class="string">&#x27;world&#x27;</span>); <span class="comment">//结果是helloworld</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;wo&#x27;</span> + <span class="number">12</span>);    <span class="comment">//结果是wo12 	</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;so&#x27;</span> + <span class="literal">true</span>);  <span class="comment">//结果是sotrue 	</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">12</span> + <span class="number">12</span>);    <span class="comment">//结果是24 	</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span> + <span class="number">12</span>);	<span class="comment">//结果是1212    </span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;    </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;zykj&#x27;</span> + age + <span class="string">&#x27;岁&#x27;</span>); <span class="comment">//结果是zykj18岁     </span></span><br><span class="line">age = age + <span class="number">1</span>;     </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;zykj&#x27;</span> + age+ <span class="string">&#x27;岁&#x27;</span>); <span class="comment">//结果是zykj19岁 </span></span><br></pre></td></tr></table></figure><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><ul><li><p>布尔型有两个值: true 和 false,其中 true 表示真,false 表示假</p></li><li><p>布尔型和数字型相加时, true 为1, false 为0</p></li></ul><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><blockquote><p>如果使用了一个<code>并未声明的变量</code>时,或者使用了<code>已经声明但还没有赋值的变量</code>时,又或者<code>使用了一个并不存在的对象属性</code>时,返回的就是 undefined</p></blockquote><p>定义方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str; </span><br><span class="line"><span class="keyword">var</span> str = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str + <span class="string">&#x27;aa&#x27;</span>); <span class="comment">//结果为undefinedaa </span></span><br><span class="line"><span class="built_in">console</span>.log(str + <span class="number">1</span>); <span class="comment">//undefined和数字相加,最后结果是NaN</span></span><br></pre></td></tr></table></figure><p>布尔环境中,它会转为 false 。数字环境中,会被转为 NaN 。字符串环境中,转为 “undefined”</p><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><blockquote><p>即不是有效的对象、数组、数字、字符串和布尔值</p></blockquote><p>定义方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//结果为null </span></span><br><span class="line"><span class="built_in">console</span>.log(b +<span class="string">&#x27;dadad&#x27;</span>); <span class="comment">//结果为nulldadad </span></span><br><span class="line"><span class="built_in">console</span>.log(b + <span class="number">1</span>); <span class="comment">//结果为1</span></span><br></pre></td></tr></table></figure><p>布尔环境中,它会转为 false 。数字环境中,会被转为0。字符串环境中,转为 “null”</p><h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><h5 id="转为字符型"><a href="#转为字符型" class="headerlink" title="转为字符型"></a>转为字符型</h5><table><thead><tr><th>方式</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td><code>toString()</code></td><td>转换为字符串</td><td>var num = 1; alert(num,toString());</td></tr><tr><td><code>String()强制转换</code></td><td>转换成字符串</td><td>var num = 1; alert(String(num));</td></tr><tr><td><code>加号拼接字符串</code></td><td>和字符串拼接的结果都是字符串</td><td>var num = 1; alert(num + “我是字符串”);</td></tr></tbody></table><p>用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量.toString()</span></span><br><span class="line"><span class="keyword">var</span> num=<span class="number">10</span>; </span><br><span class="line"><span class="keyword">var</span> str=num.toString(); </span><br><span class="line"><span class="built_in">console</span>.log(str); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str); </span><br><span class="line"><span class="comment">// console.log(typeof num); </span></span><br><span class="line"><span class="comment">// 利用 String()</span></span><br><span class="line"><span class="comment">// console.log(typeof String(num)); </span></span><br><span class="line"><span class="comment">// 利用拼接字符串的方法 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (num + <span class="string">&#x27;&#x27;</span>));</span><br></pre></td></tr></table></figure><ul><li><p>toString()可加参数,用来指定转换的基数,如为2,则转为二进制,如为8,则转为八进制,默认为10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">190</span>; </span><br><span class="line">num = num.toString(<span class="number">2</span>); </span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">//1011110</span></span><br></pre></td></tr></table></figure></li></ul><p>前两种了解即可。推荐使用第三种,亦称为<code>隐式转换</code></p><h5 id="转为数字型-重点"><a href="#转为数字型-重点" class="headerlink" title="转为数字型(重点)"></a>转为数字型(重点)</h5><table><thead><tr><th>方式</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td><code>parseInt(string)函数</code></td><td>将string类型转换成整数数值型</td><td>parselnt(‘78’);</td></tr><tr><td><code>parseFloat(string)函数</code></td><td>将string类型转换成浮点数数值</td><td>parseFloat(‘78.21’);</td></tr><tr><td><code>Number()强制转换函数</code></td><td>将string类型转换成数值型</td><td>Number(‘12’);</td></tr><tr><td><code>js 隐式转换( - * / )</code></td><td>利用算数运算隐式转换为数值型</td><td>‘12’ - 0</td></tr></tbody></table><h5 id="重点掌握"><a href="#重点掌握" class="headerlink" title="重点掌握"></a>重点掌握</h5><ul><li><p><code>parseInt()</code>、<code>parseFloat()</code>会从字符串开始处转换和返回任何的数字,自动忽略舍去非数字部分(前提是数字开头)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;88 woshi&quot;</span>));<span class="comment">// 88 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;aa 88 woshi&quot;</span>));<span class="comment">//NaN</span></span><br></pre></td></tr></table></figure></li><li><p><code>parseInt</code>可以解析”0x”或”0X”开头的数字,也可以接受另一个参数指定要解析的数字的基数(不能解析0开头的数字,除非显性地指定所使用的基数)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;ff&quot;</span>,<span class="number">16</span>));<span class="comment">// 255</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parseInt(变量) 只能转为整数型 </span></span><br><span class="line"><span class="keyword">var</span> age = prompt(<span class="string">&#x27;请输入年龄&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(age)); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;3.14&#x27;</span>));  <span class="comment">//3 取整 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;120px&#x27;</span>));  <span class="comment">//会取消px单位 </span></span><br><span class="line"><span class="comment">// parseFloat 可以把字符型的转化为数字型 得到是小数 浮点数 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14&#x27;</span>)); </span><br><span class="line"><span class="comment">// Number()</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;123&#x27;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(str)); </span><br><span class="line"><span class="comment">// 隐式转换  可以利用- * / 三种符号 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span> - <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>注: Number() 只对10十进制数字有效</p></li></ul><h5 id="转化为布尔型"><a href="#转化为布尔型" class="headerlink" title="转化为布尔型"></a>转化为布尔型</h5><table><thead><tr><th>方式</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td><code>Boolean()函数</code></td><td>其他类型转成布尔值</td><td>Boolean(“true”);</td></tr></tbody></table><p>代表空、否定的值都转化为 false,如 ‘’, 0 , null , NaN , undefined 。其他都转化为 true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">123</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><blockquote><p>浮点数运算精确度远不如整数,不能直接拿浮点数比较是否相等</p></blockquote><ul><li><p>表达式: 由<code>数字</code>、<code>运算符</code>、<code>变量</code>组成的式子</p></li><li><p>返回值: 表达式返回的值</p></li></ul><h4 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h4><ul><li><p>递增运算符(++)递减运算符(–)</p></li><li><p>放在变量前面为<code>前置递增</code> 后面为<code>后置递增</code></p><p>前置递增: 先运算再取值</p><p>后置递增: 先取值再运算</p></li><li><p>单独使用时两者结果相同</p></li></ul><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><blockquote><p>概念: 比较运算符(关系运算符)是<code>两个数据进行比较时所使用的运算符</code>,比较运算后,会<code>返回一个布尔值true/false作为比较运算的结果</code>。</p></blockquote><table><thead><tr><th>运算符名称</th><th>说明</th><th>案例</th><th>结果</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td>小于号</td><td>1 &lt; 2</td><td>true</td></tr><tr><td><code>&gt;</code></td><td>大于号</td><td>1 &gt; 2</td><td>false</td></tr><tr><td><code>&gt;=</code></td><td>大于等于号(大于或者等于)</td><td>2 &gt;= 2</td><td>true</td></tr><tr><td><code>&lt;=</code></td><td>小于等于号(小于或者等于)</td><td>3 &lt;= 2</td><td>false</td></tr><tr><td><code>==</code></td><td>判等号(会转型)</td><td>37 == 37</td><td>true</td></tr><tr><td><code>!=</code></td><td>不等号</td><td>37 != 37</td><td>false</td></tr><tr><td><code>===</code> <code>!===</code></td><td>全等 要求值和 数据类型都要一直</td><td>37 === ‘37’</td><td>false</td></tr></tbody></table><p>= 赋值<br>== 判断(会转型)<br>===全等(<code>不转型,即判断数据类型和值是否全部相等,对于对象数组函数来说则是判断是否引用同一个地址的对象数组函数</code>)</p><h4 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h4><p>instanceof 运算符(判断对象类型)</p><p><code>instance</code>: 实例</p><p>用于判断是否是某种特殊对象(数组、对象、日期)的实例</p><p>要求左边是对象,右边是一个类的名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>注: <code>instanceof</code>是通过原型对象来判断一个实例属不属于某个构造函数创建的,而不是通过构造函数的名字</p><h4 id="利用typeof获取变量数据类型"><a href="#利用typeof获取变量数据类型" class="headerlink" title="利用typeof获取变量数据类型"></a>利用typeof获取变量数据类型</h4><p>typeof 获取变量数据类型(判断基本类型)</p><ul><li>语法: typeof 变量</li></ul><blockquote><p>返回的是字符类型的小写的数据类型名称 <code>undefined</code> <code>string</code> <code>number</code> <code>function</code> <code>boolean</code>,对于包装对象和 DOM 获得的元素返回的都是 <code>object</code> 对象, null 和 数组返回的是 object</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;pink&#x27;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str); </span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> flag); </span><br><span class="line"><span class="keyword">var</span> vari = <span class="literal">undefined</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> vari); </span><br><span class="line"><span class="keyword">var</span> timer =<span class="literal">null</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> timer); </span><br><span class="line"><span class="keyword">var</span> age = prompt(<span class="string">&#x27;请输入年龄&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age);</span><br></pre></td></tr></table></figure><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与</td></tr><tr><td>||</td><td>或</td></tr><tr><td>！</td><td>非</td></tr></tbody></table><ul><li><p>如果是布尔值参与逻辑运算,则结果为布尔值</p></li><li><p>如果是<code>具体数值或表达式参与运算,则发生逻辑中断</code>,其中<code>具体数值代表真,0 &#39;&#39; null undefined NaN代表假</code></p></li><li><p><code>短路运算原理: 当有多个表达式时,左边的表达式可以确定结果时,就不再运算右边的表达式的值</code></p></li></ul><br><p><code>表达式1 &amp;&amp; 表达式2</code></p><ul><li><p>如果第一个为真,不足以确定结果,那么就返回表达式2</p></li><li><p>如果第一个为假,足以确定结果,那么就返回表达式1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> &amp;&amp; <span class="number">456</span>);   <span class="comment">//结果为0 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> &amp;&amp; <span class="number">456</span>); <span class="comment">//结果为456</span></span><br></pre></td></tr></table></figure></li></ul><p><code>表达式1 || 表达式2</code></p><ul><li><p>如果第一个为真,足以确定结果,那么就返回表达式1</p></li><li><p>如果第一个为假,不足以确定结果,那么就返回表达式2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="number">123</span> || <span class="literal">null</span> ); <span class="comment">//结果为123 </span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="literal">undefined</span> || <span class="number">456</span>);  <span class="comment">//结果为456 </span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">123</span> || <span class="number">456</span>); <span class="comment">//结果123</span></span><br><span class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//结果为0</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><ul><li><p>= 赋值 后面赋值给前面</p></li><li><p>+= x 每次加x num += 5; num = num + 5</p></li><li><p>-= x 每年减x num -= 5 ; num = num - 5</p></li><li><p>*= x 每次乘x</p></li><li><p>/= x 每次除x</p></li><li><p>%= x 每次除x取余</p></li></ul><div class="note info flat"><p>运算符优先级</p></div><ul><li><p>小括号</p></li><li><p>一元运算符 <code>++</code> <code>--</code> <code>!</code></p></li><li><p>算术运算符 先 * / % 再 + -</p></li><li><p>关系运算符</p></li><li><p>相等运算符</p></li><li><p>逻辑运算符 先 &amp;&amp; 后 ||</p></li><li><p>赋值运算符 =</p></li><li><p>逗号运算符 ,</p></li></ul><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><h4 id="三种结构"><a href="#三种结构" class="headerlink" title="三种结构"></a>三种结构</h4><p><img src="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/20200427153204.png"></p><h5 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h5><blockquote><p>按照代码先后顺序,依次执行</p></blockquote><h5 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h5><div class="note info flat"><p>根据不同的条件，执行不同的路径代码 (if while)</p></div><blockquote><p>if分支语句</p></blockquote><ul><li><p>语法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123; </span><br><span class="line">   执行语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//先判断第一个 不符合则判断下一个</span></span><br></pre></td></tr></table></figure></li><li><p>如果条件表达式结果为真,则执行大括号里面的执行语句</p></li><li><p>如果条件表达式为假,则跳过if执行后面的代码</p></li></ul><blockquote><p>三元表达式(由三元运算符 <code>? :</code> 组成的表达式)</p></blockquote><ul><li><p>语法结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件表达式 ? 表达式<span class="number">1</span>:表达式<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>如果条件表达式结果为真,则返回表达式1的值,如果为假则返回表达式2</p></li></ul><blockquote><p>switch语句</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> value1:  执行语句<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> value2:  执行语句<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: 执行最后的语句;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>匹配 case 的值,如果匹配,则运行该 case 里的值,如果都不匹配,则执行 default 里的值</p></li><li><p>表达式里的值和 case 里的值相等是用全等 === 判定的,即必须是值和数据类型完全一致才可以</p></li><li><p>必须要有 break,否则会执行下一个 case</p></li></ul><p><code>if else if 和switch的区别</code></p><ol><li><p>前者一般用判断范围 后者一般用于确定值</p></li><li><p>前者需要判断多次,后者进行判断后直接执行到程序的条件语句,效率较高</p></li><li><p>分支较少时前者效率高</p></li><li><p>分支多时后者效率高且结构更清晰</p></li></ol><h5 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h5><div class="note info flat"><p>可重复执行一些代码</p></div><blockquote><p>for循环结构</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化变量;条件表达式;操作表达式)&#123; 循环体;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>()</span><br><span class="line"> <span class="keyword">for</span>()&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//外层循环一次,里面的循环执行全部</span></span><br></pre></td></tr></table></figure><blockquote><p>while循环结构</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>()&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>记得加入计数器,防止死循环</li></ul><blockquote><p>do{} while()循环</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;&#125; <span class="keyword">while</span>()</span><br></pre></td></tr></table></figure><ul><li><p>先执行一次语句,再判断,若正确,则继续执行,否则退出</p></li><li><p>即循环体至少执行一次</p></li><li><p>总结: 一般若与数字相关,常用 for、while 和 dowhile 可以执行更加复杂的循环。while 先判断再执行,dowhile 先执行再判断</p></li></ul><blockquote><p>跳转语句 continue</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><ul><li><p>遇到continue就停止本次循环,直接跳到i++,不再执行循环体内continue后面语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123; </span><br><span class="line">   <span class="keyword">if</span> (i==<span class="number">3</span>)&#123; 	</span><br><span class="line">       <span class="keyword">continue</span>; </span><br><span class="line">  &#125; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我正在吃第&#x27;</span>+i+<span class="string">&#x27;个包子&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果:</span></span><br><span class="line"><span class="comment">我正在吃第1个包子</span></span><br><span class="line"><span class="comment">我正在吃第2个包子</span></span><br><span class="line"><span class="comment">我正在吃第4个包子</span></span><br><span class="line"><span class="comment">我正在吃第5个包子</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>结束语句 break</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><ul><li><p>遇到 break 直接跳出此循环所属的 for 语句的所有循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123; </span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>)&#123; 	</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我正在吃第&#x27;</span>+i+<span class="string">&#x27;个包子&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果:</span></span><br><span class="line"><span class="comment">我正在吃第1个包子</span></span><br><span class="line"><span class="comment">我正在吃第2个包子</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>throw</p></blockquote><ul><li><p>用于抛出异常,用信号通知发生了错误或者异常状况</p></li><li><p>异常: 发生了某种异常情况或错误时产生的一个信号。</p></li><li><p>语法格式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> expression;</span><br></pre></td></tr></table></figure><p>expression 可以使任意类型,一般为 Error 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twoArg</span>(<span class="params">o,t</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length !== <span class="number">2</span>) 	</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须是两个参数&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line">twoArg(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>注意:当抛出异常时,JS 解释器会停止当前正在执行的逻辑,跳转到最近的异常处理程序(即后面 try/catch/finally 中 catch 语句编写的程序)</p></li><li><p>常见的几个错误异常</p><ol><li>SyntaxError：语法错误</li><li>Uncaught ReferenceError：引用错误 <code>引用一个不存在的变量时发生的错误。将一个值分配给无法分配的对象，比如对函数的运行结果或者函数赋值。</code></li><li>RangeError：范围错误 <code>RangeError是当一个只超出有效范围时发生的错误。主要的有几种情况，第一是数组长度为负数，第二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。</code></li><li>TypeError类型错误 <code>变量或参数不是预期类型时发生的错误。比如使用new字符串、布尔值等原始类型和调用对象不存在的方法就会抛出这种错误，因为new命令的参数应该是一个构造函数。</code></li><li>URIError，URL错误 <code>URI相关参数不正确时抛出的错误，主要涉及encodeURI、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape(）六个函数</code><blockquote><p>try/catch/finally</p></blockquote></li></ol></li><li><p><code>try</code>用于检查抛出异常</p></li><li><p><code>catch</code>用于抓住异常,其参数便是 try 抛出的值</p></li><li><p><code>finally</code>内的代码无论如何总会执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; 		</span><br><span class="line">    <span class="keyword">var</span> n = prompt(<span class="string">&#x27;enter a number&#x27;</span>); 		</span><br><span class="line">    <span class="comment">// var t = prompt(&#x27;enter a number&#x27;); 		</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123; 			</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;wocao&#x27;</span>; 		</span><br><span class="line">    &#125; 	</span><br><span class="line">&#125; 	</span><br><span class="line"><span class="keyword">catch</span>(e)&#123; 		</span><br><span class="line">    alert(e);<span class="comment">//wocao 	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意:</p><ul><li><p>try 后面至少要跟随一个 catch 或者 finally</p></li><li><p>catch 的参数有局部作用域,只在 catch 语句中有效</p></li><li><p>如果没有 catch 从句,执行 finally 后会向上传播异常,直到找到能处理这个异常的 catch 从句</p></li></ul><h4 id="小知识-断点调试"><a href="#小知识-断点调试" class="headerlink" title="小知识: 断点调试"></a>小知识: 断点调试</h4><ul><li><code>浏览器中按F12 --&gt; sources --&gt; 找到需要要调试的文件 --&gt; 在程序的某一行设置断点</code></li><li><code>Wath</code>: 监视,通过watch可以监视变量的值的变化 ,非常的常用。</li><li><code>F11</code>: 程序单步执行,让程序行一行的执行,这个时候,观赛watch中变量的值的变化。</li><li>代码调试的能力非常重要,只有学会了代码调试,才能学会自己解决bug的能力。初学者不要觉得调试代码麻烦就不去调试,知识点花点功夫肯定学的会,但是代码调试这个东西,自己不去练,永远都学不会。</li><li>代码调试非常的简单,只要记住代码调试的这几个按钮的作用即可,后面还会学到很多的代的调试技巧。</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>一组数据的集合</p></blockquote><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><ol><li><p>利用 new 关键字创建数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure></li><li><p>利用数组字面量创建数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]; </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;dada&#x27;</span>,<span class="literal">true</span>]; </span><br><span class="line"><span class="keyword">var</span> arr=[];</span><br></pre></td></tr></table></figure><p>注意</p><ul><li><p>数组里面可以放任何数据类型</p></li><li><p>数组里面的数据称为数组元素</p></li></ul></li></ol><h4 id="数组的索引"><a href="#数组的索引" class="headerlink" title="数组的索引"></a>数组的索引</h4><ul><li><p>索引: 用来访问数组元素的序号(<code>从0开始,最大为2^32 - 1</code>)</p></li><li><p>数组的长度是元素个数,不要跟索引号混淆</p></li></ul><h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><ul><li><p>遍历: 就是把数组中的所有元素从头到尾访问一次;</p></li><li><p><code>数组名.length</code>: 动态监测数组元素的个数,一般循环遍历时长度都用这个来表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; date.length;i++)&#123; </span><br><span class="line">    alert(date[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="数组元素增加"><a href="#数组元素增加" class="headerlink" title="数组元素增加"></a>数组元素增加</h4><ol><li><p>通过修改 length 新增数组元素</p><p>先修改数组长度,再对新增元素赋值</p><p>若修改后的长度 &lt; 原先的长度,则原数组会被截取。若修改后的长度 &gt; 原先的长度,则原数组会添加多余个数的 undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.length = <span class="number">5</span>; </span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">4</span>; </span><br><span class="line">arr[<span class="number">4</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过修改数组索引的方式增加数组元素</p><p>直接对未赋值的数组元素赋值,若赋值的索引号已被占用,则会被替换为新的元素值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>注意: 不要对数组名直接赋值,否则会清除所有数组元素</p></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote><p>封装了一段可被重复调用执行的代码块,通过函数可以实现大量代码的重复使用</p></blockquote><h4 id="函数使用步骤"><a href="#函数使用步骤" class="headerlink" title="函数使用步骤"></a>函数使用步骤</h4><ul><li><p>声明函数</p><p>声明方式1:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数<span class="number">1</span>,参数<span class="number">2</span>,...</span>)</span>&#123; </span><br><span class="line">    函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意 :</em></p><ol><li><p>function 为声明函数的关键字,全部小写</p></li><li><p>函数名一般为动词,代表此函数要做什么</p></li><li><p>函数声明后被调用才能执行,不调用不执行</p></li><li><p>函数声明一般出现在 js 代码的顶层,也可以嵌套在其他函数中,但是只能嵌套在那些函数顶层中,不能出现在 if , while 或其他语句中</p></li><li><p>使用可选参数设计函数时,应该确保把可选的参数放参数列表的末尾</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="string">&#x27;hi&#x27;</span>); </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure><p>声明方式 2 :</p><p><code>var 变量名 = function(参数1,参数2,...)&#123;&#125;; (匿名函数)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 	</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Hello World!&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>函数调用</p><p><code>函数名();</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHi();</span><br></pre></td></tr></table></figure><p>或者</p><p><code>变量名(); 针对第二种声明方式</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun();</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>调用函数时一定记得写<code>小括号</code></li></ul></li></ul><h4 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>形参</code></td><td>形式上的参数 函数定义的适合 传递的参数 当前并不知道是什么</td></tr><tr><td><code>实参</code></td><td>实际上的参数 函数调用的时候传递的参数 实参是传递给形参的</td></tr></tbody></table><ul><li><p>多个参数之间逗号隔开</p></li><li><p>如果实参个数多于形参个数,会取到形参的个数</p></li><li><p>如果实参个数小于形参的个数,没有赋值的形参则为 undefined ,结果为 NaN</p></li><li><p>调用数组时直接写数组名字或者整个数组元素即可</p></li></ul><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><ul><li><p>函数只是实现某种功能,最终结果需要 return 返回数值, return 只能返回一个值</p></li><li><p>函数如果没有 return,返回的是 undefined</p></li><li><p>return 也有终止函数的功能</p></li><li><p>可以利用数组实现返回多个值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getResult</span>(<span class="params">num1,num2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> [num1 + num2, num1 - num2,num1 * num2, num1 / num2]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> re = getResult(<span class="number">1</span>,<span class="number">2</span>); </span><br><span class="line"><span class="built_in">console</span>.log(re);</span><br></pre></td></tr></table></figure></li></ul><h4 id="arguments的使用"><a href="#arguments的使用" class="headerlink" title="arguments的使用"></a>arguments的使用</h4><p>存储函数传递的所有实参</p><blockquote><p>arguments 是 Arguments对象的实例,是当前函数的一个内置对象,所有函数都内置了一个 arguments 对象, arguments 只能在函数中调用,可以按照数目获取函数的实参的参数值(调用函数时写的参数而不是定义函数时写的形参),当不确定有多少个参数传递的时候,可以用 arguments 来获取。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); </span><br><span class="line">&#125; </span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>arguments 是一个伪数组,可以进行遍历,特点如下:</p><ol><li><p>具有 length 属性</p></li><li><p>按索引方式储存数据</p></li><li><p>不具有数组的 <code>push</code> 、<code>pop</code> 等方法</p></li></ol><p>arguments的属性</p><p><code>arguments.callee</code>: 返回 arguments 所在的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whoIsCalling</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee); </span><br><span class="line">&#125; </span><br><span class="line">whoIsCalling();<span class="comment">//返回whoIsCalling函数的代码</span></span><br></pre></td></tr></table></figure><p>该属性可用来实现回调</p><h4 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h4><blockquote><p>在 JS 中,代码可以对函数进行操作。JS 中的函数是真正的数据,可以被存储在变量中、数组和对象中,可以作为参数传递给其他函数</p></blockquote><h4 id="函数的属性方法"><a href="#函数的属性方法" class="headerlink" title="函数的属性方法"></a>函数的属性方法</h4><p><code>函数.length</code>: 返回函数定义时形参的个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(f.length);<span class="comment">//2 </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);<span class="comment">//3 </span></span><br><span class="line">&#125; </span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="JS的预解析-小难点-看案例"><a href="#JS的预解析-小难点-看案例" class="headerlink" title="JS的预解析(小难点,看案例)"></a>JS的预解析(小难点,看案例)</h3><h4 id="js引擎运行分两步"><a href="#js引擎运行分两步" class="headerlink" title="js引擎运行分两步"></a>js引擎运行分两步</h4><ol><li><p>预解析: <code>js 引擎会把 js 里面所有的 var 和 function 提升到当前作用域最前面</code></p></li><li><p>代码执行: 按书写顺序依次执行代码</p></li></ol><h4 id="预解析分为"><a href="#预解析分为" class="headerlink" title="预解析分为"></a>预解析分为</h4><ol><li><p>变量预解析(变量提升): 把 var 提升到当前作用域的最前面,但不赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(num); </span><br><span class="line">&#125; </span><br><span class="line">fun();</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; </span><br><span class="line">等价于 </span><br><span class="line"><span class="keyword">var</span> num; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line">fun(); </span><br><span class="line">num = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">fn(); </span><br><span class="line"><span class="keyword">var</span> fn=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11</span>); </span><br><span class="line">&#125; </span><br><span class="line">等价于 </span><br><span class="line"><span class="keyword">var</span> fn; </span><br><span class="line">fn(); </span><br><span class="line">fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数预解析(函数提升): 把所有函数声明提升到当前作用域最前面,但不调用函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">con(); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">con</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11</span>); </span><br><span class="line">&#125; </span><br><span class="line">等价于 </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">con</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11</span>); </span><br><span class="line">&#125;</span><br><span class="line">con();</span><br></pre></td></tr></table></figure><p>注意: <code>var a = b = c = 9;</code> 预解析后等于<code>var a;a = 9;b = 9;c = 9;</code> <code>b和c变成全局变量</code></p></li></ol><h3 id="JS的对象"><a href="#JS的对象" class="headerlink" title="JS的对象"></a>JS的对象</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><blockquote><p>一组无序的相关属性和方法的集合,所有的事物 都是对象,除了字符串、数字、true、false、null 和 undefined 其他都是对象(事实上字符串数字布尔值可以被包装为包装对象)</p></blockquote><h4 id="对象由属性和方法构成"><a href="#对象由属性和方法构成" class="headerlink" title="对象由属性和方法构成"></a>对象由属性和方法构成</h4><blockquote><p>属性: 事物的特征,在对象中用属性来表示(常用名词),属性值可以是任意的js表达式,等同于变量。</p></blockquote><p>属性两种类型:</p><ul><li><p>自有属性: 直接在对象中定义的属性</p></li><li><p>继承属性: 通过原型对象继承的属性</p></li></ul><p>属性的三个特性:</p><ul><li><p><code>值(value)</code>: 属性的值</p></li><li><p><code>可写(writable)</code>: 表明是否可以设置该属性的值</p></li><li><p><code>可枚举(enumerable)</code>: 表示是否可以通过 for/in 循环返回该属性</p></li><li><p><code>可配置(configurable)</code>: 表明是否可以删除或者修改该属性</p></li><li><p><code>方法</code>: 事物的行为,在对象中用方法来表示(常用动词),即存储在对象中的函数</p></li></ul><h4 id="对象有三种"><a href="#对象有三种" class="headerlink" title="对象有三种"></a>对象有三种</h4><ol><li><p>自定义对象</p></li><li><p>内置对象</p></li><li><p>宿主对象 (前两者属于 ECMAscript ,后者属于客户端 JavaScript)</p></li></ol><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><ul><li><p>用字面量创建对象</p><p><code>var 对象名 = &#123; 属性名: &#39;属性值&#39;, 属性名: &#39;属性值&#39;, 。。。&#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">    uname: <span class="string">&#x27;zykj&#x27;</span>, </span><br><span class="line">    age: <span class="number">18</span>, </span><br><span class="line">    sex: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 	</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用对象</p><ol><li><p><code>对象名.属性名</code></p></li><li><p><code>对象名[&#39;属性名&#39;]</code> (即作为关联数组的对象,允许动态地将任意数值和任意字符串关联在一起)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.uname); </span><br><span class="line"><span class="comment">//第二种方法 对象名[&#x27;属性名&#x27;] </span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">&#x27;age&#x27;</span>]);</span><br></pre></td></tr></table></figure></li></ol><p>变量、属性、函数、方法的区别</p><ol><li><p>变量和属性都是用来存储数据,但变量需要声明属性不需要,变量可以直接写变量名调用,属性必须<code>对象名.属性名</code>调用,变量和属性基本等同</p></li><li><p>函数和方法都是实现某种功能。函数是单独声明且调用时是写<code>函数名()</code>。方法在对象里声明且调用为<code>对象.方法()</code>,对象中的函数即为方法</p></li></ol></li><li><p>用 new Object 创建对象</p><p>利用等号对属性进行赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">obj.uname = <span class="string">&#x27;zykj&#x27;</span>; </span><br><span class="line">obj.age  = <span class="number">18</span>; </span><br><span class="line">obj.sex = <span class="string">&#x27;男&#x27;</span>; </span><br><span class="line">obj.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.uname); </span><br><span class="line"><span class="built_in">console</span>.log(obj.sex);</span><br><span class="line">obj.sayHi();	</span><br></pre></td></tr></table></figure></li><li><p>利用构造函数构造多个对象</p><p><code>构造函数</code>: 就是把对象里面一些相同的属性和方法抽出封装起来的函数,即构造对象的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 构造函数名(<span class="params">形参</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">this</span>.属性 = 值; </span><br><span class="line">    <span class="built_in">this</span>.方法 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>var 对象名 = new 构造函数名(实参);</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Star</span>(<span class="params">uname,age,sex</span>)</span>&#123; 		</span><br><span class="line">    <span class="built_in">this</span>.name = uname; 		</span><br><span class="line">    <span class="built_in">this</span>.age = age; 		</span><br><span class="line">    <span class="built_in">this</span>.sex = sex; 	</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">var</span> zykj = <span class="keyword">new</span> Star(<span class="string">&#x27;zykj&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>); </span><br></pre></td></tr></table></figure><p>注意点以及构造函数执行过程:</p><ol><li><p>构造函数名字首字母一般大写</p></li><li><p>构造函数不需要 return</p></li><li><p>调用构造函数 必须使用 new 构造函数在内存中创建了一个空的对象</p></li><li><p>必须使用 this , this 指向 new 创建的空对象</p></li><li><p>执行构造函数的代码后,就会给这个空对象添加属性和方法</p></li><li><p>new 会返回创建后的对象</p></li></ol></li></ul><h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><blockquote><p>语法: for(变量 in 对象){} 该方法会<code>枚举所有可枚举的属性,包括自有属性和继承属性</code>(除非利用 Object.defineProperty() 人为设定</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(k); <span class="comment">// 遍历输出属性名    </span></span><br><span class="line">    <span class="built_in">console</span>.log(obj[k]); <span class="comment">//遍历输出属性值 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li><p>k 可以改为任意变量名,一般用 k</p></li><li><p>k 为数组</p></li><li><p>也可以用于数组！！！</p></li><li><p>该方法会枚举所有可枚举的属性,包括自有属性和继承属性(除非利用 Object.defineProperty() 人为设定为不可枚举)</p></li><li><p>许多预定义内部属性和方法,包括所有的内部方法都是不可枚举的</p></li></ul><h4 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h4><p>语法: delete 属性</p><p>删除运算数指定的<code>对象的属性、数组元素或变量</code>(严格模式不可删除)。返回布尔值</p><p>内部核心属性、客户端属性、用 var 语句声明的用户定义变量都不能删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">    num: <span class="number">10</span>, </span><br><span class="line">    age: <span class="number">20</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">delete</span> obj.num; </span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">// num消失</span></span><br></pre></td></tr></table></figure><p>注意:</p><p>delete: <code>只是断开属性和宿主对象的联系,而不会去操作属性中的属性</code></p><h4 id="检查属性的存在性"><a href="#检查属性的存在性" class="headerlink" title="检查属性的存在性"></a>检查属性的存在性</h4><ol><li><p>检测对象或数组中是否有某个属性,返回布尔值</p><p>语法: 属性名 in 对象或数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">    num: <span class="number">10</span>, </span><br><span class="line">    age: <span class="number">20</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;num&quot;</span> <span class="keyword">in</span> obj); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>注意: 该方法可以检测所有的属性方法,包括自定义类内置的和原型链上的以及原始类的属性方法</p></li><li><p>只能检测对象的自有属性</p><p>语法: <code>对象.hasOwnProperty(属性名)</code> 返回布尔值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Star</span>(<span class="params"></span>)</span>&#123; 	</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="number">1</span> </span><br><span class="line">&#125; </span><br><span class="line">Star.prototype.age = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype.male = <span class="string">&#x27;man&#x27;</span>; </span><br><span class="line"><span class="keyword">var</span> zykj = <span class="keyword">new</span> Star();     </span><br><span class="line"><span class="built_in">console</span>.log(zykj.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>));<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(zykj.hasOwnProperty(<span class="string">&#x27;male&#x27;</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="确定对象类型"><a href="#确定对象类型" class="headerlink" title="确定对象类型"></a>确定对象类型</h4><ol><li><p><code>typeof</code>: 用于区分 number、string、boolean、undefined、function、symbol 这些基本类型</p></li><li><p><code>instanceof</code>: 一旦确定了一个值不是基本类型或函数,就可以用 instanceof 来确定是哪种内建对象的实例,对于基本类型包装对象无效</p></li><li><p><code>Object.toString()</code>: 返回的是<code>[object class]</code>, class 是对象的内部类型,通常与该对象的构造函数名字对应。只能返回 Array、Function、Date、String、Number、Boolean、Symbol,其他一律返回 Object</p></li><li><p><code>constructor</code>:返回原型对象所属的类,返回的是整个构造函数</p></li></ol><h4 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h4><blockquote><p>将对象的状态转为字符串或将字符串还原为对象</p></blockquote><p>利用<code>JSON.stringify()</code>和<code>JSON.parse()</code>来序列化和还原对象</p><p>JSON(JavaScript Object Notation): JavaScript 对象表示法</p><h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><p>常用 Math Date Array String 等</p><h5 id="数学对象"><a href="#数学对象" class="headerlink" title="数学对象"></a>数学对象</h5><blockquote><p>不是构造函数,无需用 new 调用。而是可以直接调用其类属性及类方法</p></blockquote><ul><li><p>调用属性 如 输出pi值: <code>Math.PI</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.PI); <span class="comment">// 3.14....</span></span><br></pre></td></tr></table></figure></li><li><p>调用方法 如 取最大值: <code>Math.max</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果有一个或一个以上的值为非整数型,则返回 NaN</p><p>如果没有赋值,则返回 Infinity</p></li><li><p>求开根号<code>Math.sqrt(x)</code>返回 x 的开根号值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Math</span>.sqrt(<span class="number">81</span>); </span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure></li><li><p>求绝对值<code>Math.abs</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(<span class="number">1</span>)); <span class="comment">//1 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(<span class="number">-1</span>)); <span class="comment">// 1 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(<span class="string">&#x27;-1&#x27;</span>));  <span class="comment">// 1 有隐式转换 可以直接字符串转为数字型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(<span class="string">&#x27;哈哈&#x27;</span>)); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li><li><p>三个取整方法</p><ol><li><p><code>Math.floor()</code>: 向下取整,往最小了取值,不会四舍五入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">1.1</span>)); <span class="comment">// 1 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">1.9</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><code>Math.ceil()</code>: 往上取整,往最大了取,不会四舍五入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">1.9</span>)); <span class="comment">// 2 console.log(Math.ceil(1.1)); // 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>Math.round()</code>: 四舍五入取整(其他都是四舍五入,只有5是往大了取)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">1.1</span>)); <span class="comment">// 1 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">1.9</span>)); <span class="comment">// 2 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">-1.5</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>随机数</p><p><code>Math.random()</code>: 返回一个随机的0到1之间的小数(不包含0和1)且不跟参数</p><p>得到两个整数之间的随机整数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandom</span>(<span class="params">min,max</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(max-min+<span class="number">1</span>)+min));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h5><blockquote><p>Date() 日期对象 是一个构造函数 必须使用 new 来调用创建自己的日期对象</p></blockquote><ul><li><p>使用方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(date);</span><br></pre></td></tr></table></figure></li><li><p>参数写法</p><p>无参数则返回当前系统时间</p><p>数字型: 2019,10,01<br>字符型: ‘2019-10-1 08:08:08’</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>,<span class="number">10</span>,<span class="number">1</span>); </span><br><span class="line">or </span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2019-10-1 08:08:08&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>具体方法</p><p><code>返回当前年份</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.getFullYear()</span><br></pre></td></tr></table></figure><p><code>返回当前月份</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.getMonth()+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>注意: <code>是从0开始到11 所以应该+1 否则得到的月份少一个月</code></p><p><code>返回当前号数</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.getDate()</span><br></pre></td></tr></table></figure><p><code>返回周几</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.getDay()</span><br></pre></td></tr></table></figure><p>注意: <code>是从0(即星期日)开始到6(星期六)</code></p><p><code>返回小时</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.getHours();</span><br></pre></td></tr></table></figure><p><code>返回分钟</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.getMinutes()</span><br></pre></td></tr></table></figure><p><code>返回秒钟</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.getSeconds()</span><br></pre></td></tr></table></figure><p><code>返回自1970年来的总毫秒数</code></p><ol><li><p><code>对象名.getvalueOf()</code> 或者 <code>对象名.getTime()</code></p></li><li><p>var 对象名 = new Date();</p></li><li><p>console.log(Date.now());//低版本浏览器不支持</p></li></ol><p><code>获取时间</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDown</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nowTime = +<span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 返回的是当前时间总的毫秒数</span></span><br><span class="line">  <span class="keyword">var</span> inputTime = +<span class="keyword">new</span> <span class="built_in">Date</span>(time); <span class="comment">//返回的是用户输入时间的总毫秒数</span></span><br><span class="line">  <span class="keyword">var</span> times = (inputTime - nowTime) / <span class="number">1000</span>; <span class="comment">// times是剩余时间总的毫秒数</span></span><br><span class="line">  <span class="keyword">var</span> d = <span class="built_in">parseInt</span>(times / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>); <span class="comment">// 天</span></span><br><span class="line">  d = d &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + d : d;</span><br><span class="line">  <span class="keyword">var</span> h = <span class="built_in">parseInt</span>(times / <span class="number">60</span> / <span class="number">60</span> % <span class="number">24</span>); <span class="comment">// 时</span></span><br><span class="line">  h = h &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + h : h;</span><br><span class="line">  <span class="keyword">var</span> m = <span class="built_in">parseInt</span>(times / <span class="number">60</span> % <span class="number">60</span>); <span class="comment">// 分</span></span><br><span class="line">  m = m &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + m : m;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">parseInt</span>(times  % <span class="number">60</span>); <span class="comment">// 当前的秒</span></span><br><span class="line">  s = s &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + s : s;</span><br><span class="line">  <span class="keyword">return</span> d + <span class="string">&#x27;天&#x27;</span> + h + <span class="string">&#x27;时&#x27;</span> + m + <span class="string">&#x27;分&#x27;</span> + s + <span class="string">&#x27;秒&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(countDown(<span class="string">&#x27;2020-5-13 17:29:00&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ul><h5 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h5><ul><li><p>创建方式</p><ol><li><p>利用字面量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1,2,3]; </span><br><span class="line">console.log(arr[0]);</span><br></pre></td></tr></table></figure></li><li><p>利用<code>new Array()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 空数组 </span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>); <span class="comment">// 长度为2的空数组 </span></span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">// 内容为2和3的数组</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>检测变量是否为数组的方法</p><ol><li><p>利用<code>instanceof</code></p><p>变量名 instanceof Array</p><p>返回的是布尔值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []; </span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// 返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// 返回false</span></span><br></pre></td></tr></table></figure><p>注: 亦可用来判断是否为对象类型 : 变量名 instanceof Object</p></li><li><p>利用Array内置对象的行为</p><p><code>Array.isArray(变量)</code></p><p>返回的也是布尔值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// TRUE </span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// FALSE</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><ul><li><p>给数组添加元素的方法</p><ol><li><p>末尾添加</p><p><code>数组名.push(元素1,元素2,...);</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line">arr.push(<span class="number">1</span>,<span class="string">&#x27;dada&#x27;</span>); <span class="comment">// 返回结果是数组长度</span></span><br></pre></td></tr></table></figure></li><li><p>头部添加</p><p><code>数组名.unshift(元素1,元素2,...);</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line">arr.unshift(<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;purple&#x27;</span>);  <span class="comment">// 返回结果是数组长度</span></span><br></pre></td></tr></table></figure></li><li><p>尾部删除</p><p><code>数组名.pop()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.pop(); <span class="comment">//pop没有参数 返回删除的元素 一次只能删除一个元素</span></span><br></pre></td></tr></table></figure></li><li><p>头部删除</p><p><code>数组名.shift()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.shift()<span class="comment">//没有参数 返回删除的元素 一次只能删除一个</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>总结</p><table><thead><tr><th>方法名</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td><code>push(参数1...)</code></td><td><code>末尾添加一个或多个元素</code>,注意修改原数组</td><td>返回新的长度</td></tr><tr><td><code>pop()</code></td><td><code>删除数组最后一个元素</code>,把数组长度减1 无参数、修改原数组</td><td>返回它删除元素的值</td></tr><tr><td><code>unshift(参数1...)</code></td><td><code>向数组的开头添加一个或更多元素</code>,注意修改原数组</td><td>返回新的长度</td></tr><tr><td><code>shift()</code></td><td><code>删除数组的第一个元素</code>,数组长度减1 无参数。修改数组</td><td>返回第一个元素</td></tr></tbody></table></li><li><p>数组排序的方法</p><ol><li><p>数组翻转</p><p><code>数组名.reverse();</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line">arr.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure></li><li><p>数组排序</p><p><code>数组名.sort();</code>: 只对一位数起效,多位数会出错</p><p><code>数组名.sort(function(a,b)&#123; a - b&#125;)</code>: 升序排序</p><p><code>数组名.sort(function(a,b)&#123; b - a&#125;)</code>: 降序排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>]; </span><br><span class="line">arr1.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123; </span><br><span class="line">    <span class="comment">// return a - b;  升序排列 </span></span><br><span class="line">    <span class="keyword">return</span> b - a; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>获取数组元素索引方式</p><ol><li><p><code>变量名.indexOf(元素值)</code>;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;pink&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">&#x27;blue&#x27;</span>));</span><br></pre></td></tr></table></figure><p>注: 返回第一个满足条件的索引号</p><p>如果该数组里找不到元素,则返回-1</p></li><li><p><code>变量名.lastIndexOf(元素值);</code></p><p>注: 从末尾开始找 返回正序的索引号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">&#x27;blue&#x27;</span>))</span><br></pre></td></tr></table></figure><p>注: 只能用于数组,不能用于节点</p></li></ol></li></ul><ul><li><p>数组转为字符串</p><ol><li><p><code>变量名.toString();</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(arr.toString());</span><br></pre></td></tr></table></figure></li><li><p><code>变量名.join();</code></p><p>把数组所有元素转换成字符串,再把它们连接起来。可以指定一个可选的字符串来分隔结果字符串中的元素。默认为逗号分隔</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;pink&#x27;</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(arr1.join()); <span class="comment">//green,blue,pink</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.join(<span class="string">&#x27;&#x27;</span>)); <span class="comment">//greenbluepink</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>数组的截取删除连接</p><p>数组链接</p><p><code>数组名1.concat(数组名2);</code></p><p><code>数组名1.concat(元素值,元素值,...);</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line"><span class="keyword">var</span> num2 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(num1.concat(num2)); </span><br><span class="line"><span class="built_in">console</span>.log(num1.concat(num2,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]));</span><br></pre></td></tr></table></figure></li><li><p>数组删除插入(改变原数组,返回被删除的值)</p><p><code>数组名.splice(起始位置,删除个数,添加元素)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num3 = [<span class="string">&#x27;ha&#x27;</span>,<span class="string">&#x27;xi&#x27;</span>,<span class="string">&#x27;hei&#x27;</span>,<span class="string">&#x27;he&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> num4 = num3.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;en&#x27;</span>); <span class="comment">// 在第1位后插入&#x27;en&#x27; </span></span><br><span class="line"><span class="keyword">var</span> num5 = num3.splice(<span class="number">1</span>,<span class="number">1</span>); <span class="comment">//第1位开始删除一位  </span></span><br><span class="line"><span class="built_in">console</span>.log(num5); <span class="comment">// &#x27;xi&#x27;</span></span><br><span class="line"><span class="keyword">var</span> num6 = num3.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;en&#x27;</span>,<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num3); <span class="comment">// &#x27;ha&#x27; &#x27;xi&#x27; &#x27;en&#x27; &#x27;o&#x27; &#x27;he&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数组截取(不会改变原数组,只是截取出来作为新数组)</p><p><code>数组名.slice(开始位置(包含),结束位置(不包含));</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num7 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(num7.slice(<span class="number">2</span>)); <span class="comment">// 3,4,5,6 </span></span><br><span class="line"><span class="built_in">console</span>.log(num7.slice(<span class="number">1</span>,<span class="number">3</span>));<span class="comment">// 2,3 </span></span><br><span class="line"><span class="comment">// num7依旧为1,2,3,4,5,6</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h5><blockquote><p>基本包装类型: js 不仅支持数字字符串和布尔值这些数据类型,还支持 Number、String、Boolean 类,这些类是其对应基本数据类型的包装。不仅具有和基本类型一样的值,还定义了用来运算数据的属性和方法</p></blockquote><p>过程:</p><ol><li><p>字符串值内部创建一个String包装对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">String</span>(字符串值)</span><br></pre></td></tr></table></figure></li><li><p>代替原始的字符串值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 = temp;</span><br></pre></td></tr></table></figure></li><li><p>销毁temp</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp= <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>字符串不可变性: 字符串赋值后重新赋值需要重新创建内存空间,原先的内存及其值不变。所以不要大量拼接字符串,即字符串的值无法修改</p></blockquote><blockquote><p>字符串所有方法,都不会修改字符串本身内容,而是创建新的字符串</p></blockquote><p>实例方法</p><ul><li><p>根据字符串返回索引值</p><p><code>字符串名.indexOf(具体某个字符串,开始位置(默认无));</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str =<span class="string">&#x27;改革春风吹满地,春天来了&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">&#x27;春&#x27;</span>)); <span class="comment">// 返回2 </span></span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">&#x27;春&#x27;</span>,<span class="number">3</span>)); <span class="comment">// 返回8</span></span><br></pre></td></tr></table></figure></li><li><p>根据索引值返回字符串</p><ol><li><p><code>字符串变量名.charAt(索引值)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;1234&#x27;</span>; </span><br><span class="line"><span class="keyword">var</span> a = str.charAt(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>字符串变量名.charCodeAt(索引值)</code>: 返回对应位置字符的ASCII码 用于判断用户按键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str.charCodeAt(<span class="number">0</span>));</span><br></pre></td></tr></table></figure></li><li><p><code>变量名[索引值]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>字符串连接</p><p><code>字符串1.concat(字符串2);</code></p><p><code>字符串1.concat(字符,字符,...);</code></p><p>一般用加号</p></li><li><p>字符串截取</p><p><code>字符串.substr(截取起始位置,截取的字符数)</code>: 不改变原字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;改革春风吹满地&#x27;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">2</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure></li><li><p>字符串替换</p><p><code>字符串.replace(&#39;被替换的字符&#39;,&#39;替换为的字符&#39;)</code></p><p>返回的是新修改后的字符串,原字符不变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;andy&#x27;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;d&#x27;</span>)); <span class="comment">// 有一个字符串&#x27;abcoefoxyozzopp&#x27; 要求把所有o替换为* </span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;abcoefoxyozzopp&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; str1.length;i++)&#123; </span><br><span class="line">    str1 = str1.replace(<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;*&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串转为数组</p><p><code>字符串.split(&#39;分隔符&#39;)</code></p><p>原字符串用什么分割,就用什么做分隔符 不改变原字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;red,pink,blue&#x27;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str1.split(<span class="string">&#x27;,&#x27;</span>)); </span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">&#x27;red&amp;pink&amp;blue&#x27;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str3.split(<span class="string">&#x27;&amp;&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>字符串大小写转换</p><p><code>字符串.toUpperCase()</code>: 将字符串转为大写</p><p><code>字符串.toLowerCase()</code>: 将字符串转为大写</p><p>注: 字符串大小比较是按对应字母一个一个比</p></li><li><p>去除字符串左右的空格</p><p><code>字符串.trim()</code></p><p>可用来去除表单只填入空格时造成的 bug</p></li><li><p>类方法</p><p>根据 ASCII码 返回字符串</p><p><code>String.fromCharCode(num1, ..., numN)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">78</span>)); <span class="comment">//N</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="简单和复杂数据类型"><a href="#简单和复杂数据类型" class="headerlink" title="简单和复杂数据类型"></a>简单和复杂数据类型</h3><h4 id="简单数据类型-1"><a href="#简单数据类型-1" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><p>简单数据类型(基本数据类型或值类型),存储时变量中存放的是值本身,因此叫值类型,如 number、boolean、undefined、null。都具有固定的内存大小</p><p>其中 null 的返回类型是 Object ,因此一般可先用来定义对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">//结果为object</span></span><br></pre></td></tr></table></figure><p>如果有个变量打算存储为对象但没想好放什么属性和行为,那么就可以先设置为 null 类型</p><h4 id="复杂数据类型-1"><a href="#复杂数据类型-1" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><blockquote><p>复杂数据类型(引用类型): 变量中存储的仅仅是地址,如对象及其特殊类型数组和函数</p></blockquote><p>其中字符串不能很好地适合基本类型和引用类型的二分法。因为字符串不是对象,被当做基本类型,而字符串又有任意的长度,所以也可以被认为是引用类型。字符串是通过传值来比较</p><h4 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h4><ul><li><p>栈: 存放简单数据类型,由操作系统自动分配释放存放函数的参数值、局部变量的值等。简单数据类型直接查找存放在栈中的变量的值(简单数据 &gt; 栈 &gt; 变量 &gt; 值)</p></li><li><p>堆: 存放复杂数据类型,一般由程序员分配释放。复杂数据类型通过存放在栈中的变量中的地址找到存放在堆中的值(复杂数据&gt;栈&gt;变量&gt;地址&gt;堆&gt;值)</p></li></ul><h4 id="简单数据类型的传参-传值"><a href="#简单数据类型的传参-传值" class="headerlink" title="简单数据类型的传参(传值)"></a>简单数据类型的传参(传值)</h4><p>函数的形参可以看做一个变量,当把一个变量传给函数形参就等于把变量的值复制一份给形参。所以对函数内变量的修改不会影响外部变量</p><h4 id="复杂数据类型的传参-传址"><a href="#复杂数据类型的传参-传址" class="headerlink" title="复杂数据类型的传参(传址)"></a>复杂数据类型的传参(传址)</h4><p>函数的形参可以看做一个变量,当把一个变量传给函数形参就等于把变量存放的堆地址复制一份给形参,即形参和实参保存的是同个堆地址,所以操作的是同一个对象。</p><h2 id="Web-APIs"><a href="#Web-APIs" class="headerlink" title="Web APIs"></a>Web APIs</h2><div class="note danger flat"><p>本教程里的资料来源于网友的资料，自己整理以供学习。视频学习: <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/BV1k4411w7sV">黑马程序员</a></p></div><ul><li><p>DOM:文档对象模型(document object model)</p></li><li><p>BOM: 浏览器对象模型</p></li><li><p><code>API(application programming interafce,应用程序编程接口)</code>: 是一些预先定义的函数,目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力,而又无需访问源码,或理解内部工作机制的细节</p></li><li><p><code>Web API</code>: 浏览器提供的一套<code>操作浏览器功能</code>和<code>页面元素</code>的 API</p></li></ul><p>可以将 Web 浏览器当做简单操作系统,就可以 web 应用定义为 JavaScript 访问更多浏览器提供的高级服务的Web页面</p><p>文档中的 JavaScript 的角色定位: 增强用户浏览体验,使信息的获取和传递更容易。而不是降低网页的可访问性。</p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><blockquote><p>文档对象模型(document object model),处理 HTML 或者 XML 的标准编程接口,通过DOM可以改变网页的内容、结构和样式</p></blockquote><ul><li><p>文档: 一个<code>页面就是一个文档</code>,DOM中用<code>document</code>表示</p></li><li><p>元素: <code>页面中所有标签都是元素</code>,DOM用<code>element</code>表示</p></li><li><p>节点: 网页中所有内容都是节点(标签属性文本注释等),DOM中用<code>node</code>表示</p></li></ul><p><code>DOM把以上内容都看作是对象</code></p><p><img src="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/20200428211339.png"></p><h4 id="获取页面元素"><a href="#获取页面元素" class="headerlink" title="获取页面元素"></a>获取页面元素</h4><ol><li><p>根据ID获取</p></li><li><p>根据标签名获取</p></li><li><p>根据h5新增属性获取</p></li><li><p>特殊元素获取</p></li><li><p>根据 window 属性获取(不推荐)</p></li><li><p>利用 HTMLCollection (HTML集合)快捷获取</p></li></ol><ul><li><p>根据ID获取</p><p><code>document.getElementById(ID名)</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span>&gt;</span>2019-9-9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span> 	</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> timer = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;time&#x27;</span>); 	</span></span><br><span class="line"><span class="handlebars"><span class="xml">        console.log(timer); // <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span>&gt;</span>2019-9-9<span class="tag">&lt;/<span class="name">div</span>&gt;</span> 	</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">typeof</span> timer); <span class="comment">// object	</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.dir(timer); </span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意点</p><ol><li><p>因为文档页面从上往下加载,所以先得有标签, script 写到标签下面</p></li><li><p>参数 id 是大小写敏感的字符串 一定要加引号</p></li><li><p>返回的是一个文档对象 object (即有众多属性和方法)</p></li><li><p><code>console.dir</code> 打印对象所有的属性和方法</p></li></ol></li><li><p>根据标签名获取</p><p><code>document.getElementsByTagName(标签名)</code></p><p><code>父元素.getElementsByTagName(标签名)</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span> <span class="attr">id</span>=<span class="string">&quot;ol&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>9<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> lis = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(lis); <span class="comment">// HTMLCollection &#123;0: HTMLLIElement, 1: HTMLLIElement, 2: HTMLLIElement, 3: HTMLLIElement, 4: HTMLLIElement…&#125;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(lis[<span class="number">2</span>]); <span class="comment">// &lt;li&gt;3&lt;/li&gt;</span></span></span><br><span class="line">    </span><br><span class="line">    for(i = 0;i&lt;lis.length;i++)&#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(lis[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ol = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;ol&quot;</span>); </span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(ol); <span class="comment">// HTMLCollection &#123;0: HTMLOListElement, 1: HTMLOListElement, constructor:</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(ol[<span class="number">0</span>].getElementsByTagName(<span class="string">&quot;li&quot;</span>)); <span class="comment">// HTMLCollection &#123;0: HTMLLIElement, 1: HTMLLIElement, 2: HTMLLIElement, constructor: Object&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ol = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ol&#x27;</span>); </span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(ol.getElementsByTagName(<span class="string">&#x27;li&#x27;</span>)); <span class="comment">// HTMLCollection &#123;0: HTMLLIElement, 1: HTMLLIElement, 2: HTMLLIElement, constructor: Object&#125;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意:</p><ol><li><p>返回的值是伪数组,即所有相应标签的集合,即以伪数组的形式存储(无论有多少个,即使是0个),单个元素仍为对象,得到的元素是动态的</p></li><li><p>可用遍历方式打印里面具体的元素对象</p></li><li><p>通过父元素获取标签时,父元素必须是具体的单个对象,如果父元素是通过标签名获取,则获取其子元素时应加上索引号。也可以直接通过 ID 获取不加索引号</p></li></ol></li><li><p>H5新增,返回的是 NodeList 对象</p><p><code>document.getElementsByClassName(标签名)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;box&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(box); <span class="comment">// HTMLCollection &#123;0: HTMLDivElement, constructor: Object&#125;</span></span><br></pre></td></tr></table></figure><p>注意</p><ol><li>返回的依旧是伪数组形式</li></ol><br><p><code>document.querySelector(选择器)如(#id,.类名,标签名)</code></p><p>返回指定选择器的<code>第一个元素</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstbox = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(firstbox); </span><br><span class="line"><span class="keyword">var</span> nav = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#nav&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(nav); </span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;li&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(one);</span><br></pre></td></tr></table></figure><p>注意: <code>永远只会返回一个元素对象</code></p><br><p><code>document.querySelectorAll(选择器)</code></p><p>返回选定选择器的所有元素集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allbox = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.box&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(allbox); </span><br><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(lis[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>注意: 返回的是伪数组形式(无论对象元素数量多少)</p></li><li><p>获取特殊元素</p><ol><li><p>获取 body 元素</p><p><code>document.body</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bodyEle = <span class="built_in">document</span>.body; </span><br><span class="line"><span class="built_in">console</span>.log(bodyEle);</span><br></pre></td></tr></table></figure></li><li><p>获取 html 元素</p><p><code>document.documenElement</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> htmlEle = <span class="built_in">document</span>.documentElement; </span><br><span class="line"><span class="built_in">console</span>.log(htmlEle);</span><br></pre></td></tr></table></figure></li><li><p>获取 head 元素</p><p><code>document.head</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.head);</span><br></pre></td></tr></table></figure></li></ol></li></ul><ul><li><p>根据 window 属性获取赋予 id 、name 属性的 html 标签(不推荐)</p><blockquote><p>如果HTML文档中用 id 属性为元素命名,并且 Window 对象没有该名字的属性,那么 Window 对象会创建一个同名属性,该属性指向以该名字命名 id 属性的 html 元素</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span> 	</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">window</span>.one); <span class="comment">// &lt;div id=&quot;one&quot;&gt;&lt;/div&gt; </span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于 a、iframe、img、form 等标签来说,如果有 name 属性,那么也会有与上面同样的表现。如果有多个相同 name 属性,则具有该名称的隐式全局变量会引用一个伪数组对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ii&quot;</span>&gt;</span> 	</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ii&quot;</span>&gt;</span> 	</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span> </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.ii);<span class="comment">// HTMLCollection(2) [img, img, ii: img] </span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>利用 HTMLCollection (HTML集合)快捷获取,返回的是 HTMLCollection 对象</p><blockquote><p>HTMLDocument中定义了一些属性,如images、forms、links可以快速获取img、form、a等标签</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span> 	</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.images);<span class="comment">//HTMLCollection(2) [img, img] 	</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h4><blockquote><p>可以被 javascript 侦测到的行为</p></blockquote><p>事件三要素</p><ol><li><p>事件源(可以通过获取对象方式获取)</p></li><li><p>事件类型(设置事件的触发方式)</p></li><li><p>事件处理程序(通过函数赋值方式完成)</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>); </span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="string">&#x27;点秋香&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意: 第一句为获取事件源<code>.onclick</code>为事件类型 function 及后面为事件处理程序</p><p>事件执行三步骤:</p><ol><li><p>获取事件源</p></li><li><p>绑定事件</p></li><li><p>添加事件处理程序</p></li></ol><h4 id="常见鼠标事件"><a href="#常见鼠标事件" class="headerlink" title="常见鼠标事件"></a>常见鼠标事件</h4><table><thead><tr><th>鼠标事件</th><th>触发事件</th></tr></thead><tbody><tr><td><code>onclick</code></td><td>鼠标点击左键触发</td></tr><tr><td><code>ondblclick</code></td><td>鼠标双击事件</td></tr><tr><td><code>onmouseover</code></td><td>鼠标经过触发</td></tr><tr><td><code>onmouseout</code></td><td>鼠标离开触发</td></tr><tr><td><code>onfocus</code></td><td>获取鼠标焦点触发</td></tr><tr><td><code>onblur</code></td><td>失去鼠标焦点触发</td></tr><tr><td><code>onmousemove</code></td><td>鼠标移动触发</td></tr><tr><td><code>onmouseup</code></td><td>鼠标弹起触发</td></tr><tr><td><code>onmousedown</code></td><td>鼠标按下触发</td></tr></tbody></table><h4 id="改变元素内容-不适用于表单"><a href="#改变元素内容-不适用于表单" class="headerlink" title="改变元素内容(不适用于表单)"></a>改变元素内容(不适用于表单)</h4><ol><li><p><code>innerText</code>: 不识别 html 标签,非标准,会去除空格和换行</p></li><li><p><code>innerHTML</code>: 识别 html 标签,W3C 标准,不会去除空格和换行</p></li><li><p><code>insertAdjacentHTML(位置,目标元素)</code>: 可以实现在目标元素中特定位置插入<code>字符串</code><br>位置</p><ul><li><code>beforebegin</code>：元素自身的前面。</li><li><code>afterbegin</code>：插入元素内部的第一个子节点之前。</li><li><code>beforeend</code>：插入元素内部的最后一个子节点之后。</li><li><code>afterend</code>：元素自身的后面。</li></ul></li></ol><p>注: 两个属性可读写,可以获取元素内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(p.innerText); </span><br><span class="line"><span class="built_in">console</span>.log(p.innerHTML);</span><br></pre></td></tr></table></figure><p>常用元素属性修改: <code>src</code>、<code>href</code>、<code>title</code>、<code>alt</code>、<code>id</code></p><h4 id="改变表单元素内容"><a href="#改变表单元素内容" class="headerlink" title="改变表单元素内容"></a>改变表单元素内容</h4><p><code>input.value</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;input&#x27;</span>); </span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    input.value = <span class="string">&#x27;haha&#x27;</span>; </span><br><span class="line">    <span class="built_in">this</span>.disabled = <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ol><li><p>表单元素更改只能用 value</p></li><li><p>disabled 实现表单禁用</p></li><li><p>函数中的 this 指向函数的调用者</p></li><li><p>这些都是属性不是样式,不用写 <code>style</code> <code>img</code> <code>src</code> 等等</p></li></ol><p>可以通过修改表单type类型实现密码明文密文的转换</p><h4 id="改变元素对象样式"><a href="#改变元素对象样式" class="headerlink" title="改变元素对象样式"></a>改变元素对象样式</h4><ol><li><p><code>element.style.样式 = &#39;属性值&#39;;</code>: 一般用于样式较少或功能简单的情况下使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="comment">// div.style 里面的样式用驼峰命名法</span></span><br><span class="line">    <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;purple&#x27;</span>; </span><br><span class="line">    <span class="built_in">this</span>.style.width = <span class="string">&#x27;400px&#x27;</span>; <span class="comment">// 修改后的样式为行内样式 权重比较高</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ol><li><p>利用 js style 修改的样式都得用驼峰命名法 如 <code>backgoroundColor</code>、<code>fontSize</code></p></li><li><p>js <code>修改后的样式都以行内样式生成,权重高</code></p></li><li><p>样式的属性都是在 style 中,所以需要些 <code>xx.style.属性</code></p></li></ol></li><li><p>通过<code>element.className</code>增加类名从而修改样式(适用于样式较多,功能复杂的情况使用)</p><p>即在 css 先定义好新的样式在新的类名中,再在 js 中对目标元素设置事件利用 <code>className</code> 更换新的类</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.change</span> &#123; 		</span></span><br><span class="line">    background-color: purple; 		</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>; 		</span></span><br><span class="line">    font-size: 25px; 		</span><br><span class="line">    margin-top: 100px; 	</span><br><span class="line">    &#125; </span><br><span class="line"> <span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span> 	   </span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> test = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>); 	</span></span><br><span class="line"><span class="javascript">    test.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span></span><br><span class="line"><span class="javascript">    <span class="comment">//将当前类名改为change 从而改变样式 		</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.className = <span class="string">&#x27;change&#x27;</span>; 	</span></span><br><span class="line">    &#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意: <code>className 会完全覆盖先前的类名</code></p><p><code>若想同时保留新旧类名 则可以在添加时新旧一起写</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.className = <span class="string">&#x27;first change&#x27;</span>;   </span><br></pre></td></tr></table></figure></li></ol><h4 id="获得失去焦点"><a href="#获得失去焦点" class="headerlink" title="获得失去焦点"></a>获得失去焦点</h4><ul><li><p>示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">&quot;input&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>获得焦点(即点击输入框时)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input.onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;获得焦点&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>失去焦点(取消点击输入框时)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input.onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失去焦点&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="排他思想-算法"><a href="#排他思想-算法" class="headerlink" title="排他思想 (算法)"></a>排他思想 (算法)</h4><blockquote><p>如果有同一组元素,<code>想要某一个元素实现某种样式</code>,那么就需要排他思想</p></blockquote><p><em>步骤 :</em></p><ol><li><p>先排除其他人的样式</p></li><li><p>再设置自己的样式</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>;i &lt; btns.length;i++)&#123; </span><br><span class="line">    btns[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 	</span><br><span class="line">        <span class="comment">// 想把所有按钮颜色去掉 	</span></span><br><span class="line">        <span class="comment">// 再修改当前颜色 	</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; btns.length;i ++)&#123; 		</span><br><span class="line">            btns[i].style.backgroundColor = <span class="string">&#x27;&#x27;</span>; 	</span><br><span class="line">        &#125; 	</span><br><span class="line">        <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;pink&#x27;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取自定义属性"><a href="#获取自定义属性" class="headerlink" title="获取自定义属性"></a>获取自定义属性</h4><ul><li><p>获取属性一般有两种</p><ol><li><p><code>element.属性</code></p></li><li><p><code>element.getAttribute(&#39;属性&#39;)</code></p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">&#x27;index&#x27;</span>));</span><br></pre></td></tr></table></figure><p>区别</p><ol><li><p>第一种用于获取<code>元素本身自带的属性</code></p></li><li><p>第二种一般用于获取通过 <code>setAttribute</code> 自定义的属性(即程序员自己定义的属性),通过 <code>setAttribute</code> 设置的属性只能用第二种获取</p></li></ol></li><li><p>设置属性值的方法</p><ol><li><p><code>element.属性 = &#39;属性值&#39;;</code></p></li><li><p><code>element.setAttribute(&#39;属性&#39;,&#39;值&#39;)</code>;</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line">div.setAttribute(<span class="string">&#x27;index&#x27;</span>,<span class="string">&#x27;2&#x27;</span>);</span><br></pre></td></tr></table></figure><p>自定义属性也可以通过第一种设置,但只能用<code>xxx.属性名</code>获取</p></li><li><p>移除属性的方法</p><p><code>element.removeAttribute(&#39;属性&#39;);</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.removeAttribute(<span class="string">&#x27;index&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>h5新增自定义属性方法</p><p><code>data-属性名</code></p><p><code>data-开头的属性必定是自定义属性</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-time</span>=<span class="string">&quot;2&quot;</span> <span class="attr">data-list-name</span>=<span class="string">&#x27;andy&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>获取data自定义属性方法有两种:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-time</span>=<span class="string">&quot;2&quot;</span> <span class="attr">data-list-name</span>=<span class="string">&#x27;andy&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>element.getAttribute(<code>&#39;data-属性名&#39;</code>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">&#x27;data-list-name&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">&#x27;data-time&#x27;</span>));</span><br><span class="line">div.setAttribute(<span class="string">&#x27;data-index&#x27;</span>,<span class="number">2</span>); <span class="comment">//设置属性值</span></span><br></pre></td></tr></table></figure></li><li><p><code>element.dataset.data后面的属性名</code> 或 <code>element.dataset[&#39;data后面的属性名&#39;]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(div.dataset);</span><br><span class="line"><span class="built_in">console</span>.log(div.dataset.index);</span><br><span class="line"><span class="built_in">console</span>.log(div.dataset[<span class="string">&#x27;index&#x27;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(div.dataset[<span class="string">&#x27;listName&#x27;</span>]);</span><br></pre></td></tr></table></figure></li></ol><p>特别注意: 对于 <code>data-</code> 后面还有横杠的命名的属性值在利用 dataset 获取时应该用<code>驼峰命名法</code>, getAttribute 则不用</p></li></ul><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><blockquote><p>页面中所有内容都是节点,用 node 表示</p></blockquote><h5 id="节点的三个属性"><a href="#节点的三个属性" class="headerlink" title="节点的三个属性"></a>节点的三个属性</h5><ol><li><p>节点类型(<code>nodeType</code>)</p></li><li><p>节点名称(<code>nodeName</code>)</p></li><li><p>节点值(<code>nodeValue</code>)</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">元素节点nodeType &#x3D; 1</span><br><span class="line"></span><br><span class="line">属性节点nodeType &#x3D; 2</span><br><span class="line"></span><br><span class="line">文本节点nodeType &#x3D; 3 (文本节点包含文字、空格、换行等)</span><br></pre></td></tr></table></figure><p>操作的主要是元素节点</p><blockquote><p>节点可以划分为不同的层级关系,常见的是父子兄层级节点</p></blockquote><h5 id="父子节点操作"><a href="#父子节点操作" class="headerlink" title="父子节点操作"></a>父子节点操作</h5><ul><li><p>获取父节点</p><p><code>node.parentNode(获得最近的父节点,如果找不到则返回 NULL )</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> erweima = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.erweima&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(erweima.parentNode);</span><br></pre></td></tr></table></figure></li><li><p>获取子节点</p><p><code>node.childNodes</code>: 返回的是元素节点以及文本节点</p><p><code>node.children</code>:只返回元素节点 获得的是伪数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ul.children);</span><br></pre></td></tr></table></figure></li><li><p>获取第一个和最后一个子节点</p><p><code>node.firstChild</code></p><p><code>node.lastChild</code></p><p>以上都返回包括文本节点在内的所有节点 <code>不常用</code></p><p><code>node.firstElementChild</code></p><p><code>node.lastElementChild</code></p><p>只返回元素节点,但是有兼容性问题</p><p>实际写法</p><p><code>node.children[0] 返回第一个</code></p><p><code>node.children[node.children.length-1] 返回最后一个</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ol.children[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ol.children[ol.children.length<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure></li><li><p>获取兄弟节点</p><p><code>node.nextSibling</code>: 下一个兄弟节点</p><p><code>node.previousSibling</code>: 上一个兄弟节点</p><p>以上获取的都是包含<code>文本节点元素节点(#text)</code>的兄弟节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(div.nextSibling); </span><br><span class="line"><span class="built_in">console</span>.log(div.previousSibling);</span><br></pre></td></tr></table></figure><p><code>node.nextElementSibling</code>: 下一个兄弟元素节点</p><p><code>node.previousElementSibling</code>: 上一个兄弟元素节点</p><p>以上都只获取为元素节点的兄弟节点 有兼容性问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(div.nextElementSibling); </span><br><span class="line"><span class="built_in">console</span>.log(div.previousElementSibling);</span><br></pre></td></tr></table></figure><p>解决方案: 自己利用节点类型 nodeType 封装一个函数</p></li><li><p>创建节点</p><p><code>document.createElement(元素名称)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br></pre></td></tr></table></figure><p>添加节点(两种方法)</p><ol><li><p><code>node.appendChild(child);</code>: node 为父节点 child 为新创建的节点 添加到父级最后面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">ul.appendChild(li);</span><br></pre></td></tr></table></figure></li><li><p><code>node.insertBefore(child,指定位置)</code>: 即将新创建的child节点添加到指定元素之前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lili = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>); </span><br><span class="line">ul.insertBefore(lili,ul.children[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>删除节点</p><p><code>node.removeChild()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ul.removeChild(ul.children[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></li><li><p>克隆节点</p><p><code>node.cloneNode()</code></p><p>括号里参数如果为<code>空或者是false</code>,则是<code>浅拷贝</code> 则只复制 <code>node 本身</code>、<code>不复制里面的子节点</code><br>括号里参数如果为<code>true</code>,则是<code>深拷贝</code> 则复制 <code>node 本身、里面的子节点</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lili = ul.children[<span class="number">0</span>].cloneNode(); <span class="comment">// li </span></span><br><span class="line"><span class="keyword">var</span> lili = ul.children[<span class="number">0</span>].cloneNode(<span class="literal">true</span>); <span class="comment">// &lt;li&gt;1&lt;/li&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建文档碎片</p><p><code>document.createDocumentFragment()</code></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/en-US/docs/DOM/DocumentFragment"><code>DocumentFragments</code></a> 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。</p><p>因为文档片段存在于<strong>内存中</strong>，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面<a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Reflow">回流</a>（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。</p></li><li><p>节点的文本内容</p><p><code>node.textContent</code></p><p>textContent 属性设置或者返回指定节点的文本内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;item1&quot;</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;item2&quot;</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;item3&quot;</span>&gt;</span>Tea<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>单击按钮获取列表元素的文本内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;myFunction()&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> lst=<span class="built_in">document</span>.getElementById(<span class="string">&quot;myList&quot;</span>);</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>);  </span></span><br><span class="line">	x.innerHTML=lst.textContent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">结果: Coffee哈哈哈Tea</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>附: 阻止链接跳转可以对 a 的 href 设置为<code>javascript:; 或 javacript:void(0)</code></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><p>获取父节点 <code>node.parentNode</code></p></li><li><p>获取子节点 <code>node.children</code></p></li><li><p>获取兄弟节点<code>node.nextElementSiibling</code> <code>node.previousElementSibling(兼容性差)</code></p></li><li><p>创建节点 <code>document.createElement(节点类型)</code></p></li><li><p>添加节点 尾部添加 <code>node.appendChild() 某个元素之前添加</code> <code>node.insertBefore(child,指定元素)</code></p></li><li><p>删除节点 <code>node.removeChild() node为删除目标元素的父元素</code></p></li><li><p>复制节点 <code>node.cloneNode()</code></p></li></ul><h4 id="三种动态创建元素区别"><a href="#三种动态创建元素区别" class="headerlink" title="三种动态创建元素区别"></a>三种动态创建元素区别</h4><ol><li><p><code>document.write()</code></p></li><li><p><code>element.innerHTML()</code> 配合字符串使用</p></li><li><p><code>document.createElement()</code>配合 append、insertbefore 使用</p></li></ol><p>注意</p><ol><li><p><code>document.wirte</code> 如果是文档流执行完毕写入,<code>会导致页面全部重绘</code></p></li><li><p><code>innerHTML</code> 创建多个元素效率更高 前提是不要拼接字符串 而是通过先创建数组再将数组转换为字符串赋予对象的形式</p></li><li><p><code>createElement()</code>创建多个元素效率相对 innerHTML 的数组赋值方式较低,但是结构更清晰</p></li></ol><p>总结: <code>不同浏览器下,采取数组赋值的 innerHTML 效率比 creatElement 高</code></p><h3 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h3><h4 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h4><blockquote><p>传统方式和监听注册方式</p></blockquote><ol><li><p>传统方式(最简单的方式,即将函数赋值给目标对象的事件属性,属性名字都以<code>&quot;on&quot;开头</code>)</p><p><code>变量名.onclick = funciton()&#123;&#125;</code></p><p>特点: <code>唯一性</code>,即同个元素同个事件只能设置一个处理函数,如果重复注册则以最新一个(最后一个)为准</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>); 	</span><br><span class="line">btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    alert(<span class="string">&#x27;HI&#x27;</span>); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>监听注册方式(推荐 为 W3C标准 IE9 之前不支持)</p><p><code>变量名.addEventListener(&#39;事件触发方式&#39;,处理函数,事件流执行顺序参数(布尔值))</code></p><p>特点: 用一个元素同一个事件可以注册多个监听器,按注册顺序依次执行</p><p>注意: <code>事件触发方式</code>不能带 on ,且因为是字符串必须加引号;<code>处理函数</code>可以写函数名也可以写整个函数,当事件发生时，会调用该监听函数;<code>事件流执行顺序参数</code>可选参数,是一个布尔值,默认为 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btns[<span class="number">1</span>].addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    alert(<span class="string">&#x27;22&#x27;</span>); 	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>attachEvent方式( IE9 之前支持 了解即可)</p><p><code>变量名.attachEvent(事件类型(带on),时间处理函数)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btns[<span class="number">2</span>].attachEvent(<span class="string">&#x27;onclick&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">   alert(<span class="string">&#x27;11&#x27;</span>); 	</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p><code>在元素上写事件和 addEventListener() 的区别</code></p><ul><li><p>onclick 添加事件不能绑定多个事件,后面绑定的会覆盖前面的。而 addEventListener 能添加多个事件绑定,按顺序执行。</p></li><li><p>addEventListener 方式,不支持低版本的 IE。( attachEvent 支持 IE )。</p></li><li><p>普通方式绑定事件后,不可以取消。addEventListener 绑定后则可以用 removeEventListener 取消。</p></li><li><p>addEventListener 是 W3C DOM 规范中提供的注册事件监听器的方法。</p></li><li><p>对于传统事件注册记得加 on ,如 onclick , onkeydown 等</p></li></ul><h4 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h4><ol><li><p>对于传统方式注册的事件</p><p><code>变量名.事件类型 = null</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>); 	</span><br><span class="line">divs[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    alert(<span class="string">&#x27;11&#x27;</span>); 		</span><br><span class="line">    divs[<span class="number">0</span>].onclick = <span class="literal">null</span>; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于监听事件注册的事件</p><p><code>变量名.removeEventListener(删除的事件类型,删除的函数)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">divs[<span class="number">1</span>].addEventListener(<span class="string">&#x27;click&#x27;</span>,fn); 	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    alert(<span class="string">&#x27;22&#x27;</span>); 		</span><br><span class="line">    divs[<span class="number">1</span>].removeEventListener(<span class="string">&#x27;click&#x27;</span>,fn); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于attachEvent注册的事件(了解)</p><p><code>变量名.detachEvent(删除的事件类型,删除的函数)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">divs[<span class="number">2</span>].attachEvent(<span class="string">&#x27;onclick&#x27;</span>,fn1); 	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    alert(<span class="string">&#x27;33&#x27;</span>); 		</span><br><span class="line">    divs[<span class="number">2</span>].detachEvent(<span class="string">&#x27;onclick&#x27;</span>,fn1); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总结:</p><ul><li><p>注册事件</p><p><code>node.onclick</code></p><p><code>node.addEventListener(&#39;事件类型&#39;,处理程序,冒泡与否值)</code></p></li><li><p>删除事件</p><p><code>node.onclick = null;</code></p><p><code>node.removeEventListener (&#39;事件类型&#39;,处理程序)</code></p></li></ul><h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><blockquote><p>页面中获取接收事件的顺序</p></blockquote><blockquote><p>DOM 事件流: 事件发生时会在元素节点之间按照特定顺序传播</p></blockquote><p>DOM事件流有三个阶段:</p><ol><li><p>捕获阶段</p><p>事件发生时在页面中从 document 往下一级一级传播的过程</p></li><li><p>当前目标阶段</p><p>事件到达设置了该事件的元素时的阶段</p></li><li><p>冒泡阶段</p><p>事件接受后从事件触发节点逐级向上传播到 DOM 最顶层节点的过程</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/202004291200905.png"></p><p>注意:</p><ul><li><p>JS 只能执行捕获或者冒泡其中一个阶段</p></li><li><p><code>onclick</code> 和 <code>attachEvent</code> 只能获得冒泡阶段</p></li><li><p><code>addEventListener</code> 第三个参数如果是 true ,则为捕获阶段(很少用)。如果是 false(默认),则为冒泡阶段</p></li><li><p>一些事件是没有冒泡的,如 onblur , onfocus , onmouseenter , onmouseleave</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//捕获阶段</span></span><br><span class="line"><span class="keyword">var</span> son = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>); 	</span><br><span class="line">son.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 	</span><br><span class="line">	alert(<span class="string">&#x27;son&#x27;</span>); 	</span><br><span class="line">&#125;,<span class="literal">true</span>)	</span><br><span class="line"><span class="keyword">var</span> father = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.father&#x27;</span>); 	</span><br><span class="line">father.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 	</span><br><span class="line">	alert(<span class="string">&#x27;father&#x27;</span>); 	</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 因为是捕获阶段 所以先弹出 father 再弹出son</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡阶段</span></span><br><span class="line"><span class="keyword">var</span> son = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>); 	</span><br><span class="line">son.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    alert(<span class="string">&#x27;son&#x27;</span>); 	</span><br><span class="line">&#125;,<span class="literal">false</span>)	</span><br><span class="line"><span class="keyword">var</span> father = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.father&#x27;</span>); 	</span><br><span class="line">father.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    alert(<span class="string">&#x27;father&#x27;</span>); 	</span><br><span class="line">&#125;,<span class="literal">false</span>)	</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    alert(<span class="string">&#x27;document&#x27;</span>); </span><br><span class="line"></span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">//因为是冒泡,所以如果点击father,则只弹father。点击son,则先弹出son,再弹出father</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><blockquote><p>事件的一系列相关数据的集合</p></blockquote><p><code>xxx.onclick = function(event)&#123;&#125;</code></p><p>其中event就是事件对象,写到事件的处理函数小括号里,可以任意命名(一般为 e )</p><p>事件对象只有有了事件才会存在,不需要传递参数,系统自动创建</p><p>存在兼容性问题 ie678 无法识别,只能通过 <code>window.event</code> 获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementByTagName(<span class="string">&#x27;div&#x27;</span>); 		</span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; 		 </span><br><span class="line">    <span class="built_in">console</span>.log(e); 			</span><br><span class="line">    <span class="comment">// 兼容写法 			</span></span><br><span class="line">    e = e || <span class="built_in">window</span>.event; <span class="comment">//说明： 如果 e 为真的话 e = e ,否则为假的话 e = window.event 			</span></span><br><span class="line">    <span class="built_in">console</span>.log(e); 		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数参数有事件对象参数e以及自定义参数时,自定义参数应该在事件对象之前</p><h4 id="常见事件对象的属性和方法"><a href="#常见事件对象的属性和方法" class="headerlink" title="常见事件对象的属性和方法"></a>常见事件对象的属性和方法</h4><p><code>e.target</code>: 返回触发事件的对象(ie678不兼容)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>); 	</span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; 		</span><br><span class="line">    <span class="built_in">console</span>.log(e.target); 		</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); 	</span><br><span class="line">&#125;)   </span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>); 	</span><br><span class="line">ul.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; 		</span><br><span class="line">    <span class="comment">// 点击li触发 返回的是li 			</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.target);<span class="comment">//绑定事件的是ul 返回的是ul 		</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); 	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意:</p><ol><li><p>this 和 target 的区别为<code>前者返回的是绑定事件的对象</code>,<code>后者为触发事件的对象</code>,即<code>点击谁之后触发了事件就返回哪个</code>。</p></li><li><p>对于 ie678 应该用 <code>e.srcElement</code>(了解)</p></li><li><p>与 this 相似的属性是 <code>e.currentTarget</code>(了解)</p></li></ol><blockquote><p>返回事件类型</p></blockquote><p><code>e.type</code>: 返回 click mouseover 等,没有on</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>); 	</span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>,fn); 	</span><br><span class="line">div.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>,fn); 	</span><br><span class="line">div.addEventListener(<span class="string">&#x27;mouseout&#x27;</span>,fn); 	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">e</span>)</span>&#123; 		</span><br><span class="line">    <span class="built_in">console</span>.log(e.type)	</span><br><span class="line">&#125; <span class="comment">// 返回click 或 mouseover mouseout</span></span><br></pre></td></tr></table></figure><blockquote><p>阻止默认行为(比如让链接不跳转,让提交按钮不提交)</p></blockquote><ol><li><p>对于监听注册事件</p><p><code>e.preventDefault()</code>//只适用于高版本浏览器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;a&#x27;</span>); 	</span><br><span class="line">a.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; 		</span><br><span class="line">    e.preventDefault(); <span class="comment">//dom标准写法 	</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>对于传统注册方式</p><p><code>e.preventDefault()</code></p><p><code>e.returnValue()</code>适用于 ie678</p><p>return false 没有兼容性问题 但是后面的代码无法执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">a.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//普通浏览器 e.preventDefault(); 方法</span></span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="comment">//低版本浏览器 ie678 returnValue 属性</span></span><br><span class="line">  e.returnValue;</span><br><span class="line">  <span class="comment">//return false 没有兼容性问题 但是后面的代码无法执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; 	</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>阻止冒泡</p></blockquote><ol><li><p><code>e.stopPropagation(); // ie678不兼容</code></p><p>阻止当前对象执行事件后向上冒泡</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> son = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>); 	</span><br><span class="line">son.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; 		</span><br><span class="line">    alert(<span class="string">&#x27;son&#x27;</span>); 		</span><br><span class="line">    e.stopPropagation(); 	</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><code>e.cancelBubble = true; //ie678兼容写法(了解)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> son = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>); 	</span><br><span class="line">son.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; 		</span><br><span class="line">    alert(<span class="string">&#x27;son&#x27;</span>); 		</span><br><span class="line">    e.cancelBubble = <span class="literal">true</span>; <span class="comment">//ie678兼容写法 	</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li></ol><p>总结</p><ul><li><p><code>e.target</code>: 返回触发了事件的对象</p></li><li><p><code>e.type</code>: 返回事件类型</p></li><li><p><code>e.preventDefault()</code>: 阻止默认行为</p></li><li><p><code>e.stopPropagation()</code>: 阻止当前冒泡</p></li></ul><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> 		</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> 		</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> 		</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span> 		</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span> 	</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span> 	</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span> 		</span><br><span class="line"><span class="javascript">    <span class="comment">// 给父节点设置事件 		</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>); 		</span></span><br><span class="line"><span class="javascript">    ul.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; 	</span></span><br><span class="line"><span class="javascript">        e.target.style.backgroundColor = <span class="string">&#x27;red&#x27;</span>;		      </span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;弹出了一条信息&#x27;</span>); <span class="comment">//因为事件冒泡所以点击li后上升到ul从而触发事件  		</span></span></span><br><span class="line">    &#125;)	</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事件调用顺序</p><ul><li>通过设置对象属性或 HTML 属性注册的处理程序一直优先调用</li><li>使用 <code>addEventListener()</code> 注册的处理程序按照它们的注册顺序调用</li><li>使用 <code>attachEvent()</code> 注册的处理程序可能按照任何顺序调用,所以代码不应该依赖于调用顺序</li></ul><h4 id="常用鼠标事件"><a href="#常用鼠标事件" class="headerlink" title="常用鼠标事件"></a>常用鼠标事件</h4><ul><li><p>禁止右键菜单</p><p><code>利用 contextmenu 事件类型中的 e.preventDefault</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;contextmenu&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; 		</span><br><span class="line">    e.preventDefault(); 	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>禁止选中文字</p><p><code>利用 selectstart 事件类型中的 e.preventDefault</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;selectstart&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; 		</span><br><span class="line">    e.preventDefault(); 	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>鼠标事件对象</p><p><code>e.clientX(Y)</code>: 鼠标相对于浏览器页面的xy坐标(页面滚动也不影响)</p><p><code>e.pageX(Y)</code>: 鼠标相对于整个页面文档的xy坐标</p><p><code>e.screenX(Y)</code>: 鼠标相对于电脑屏幕的xy坐标</p><p>注意: <code>通过此事件对对象位置进行改变时记得加px</code>！！！</p></li></ul><h4 id="常用键盘事件"><a href="#常用键盘事件" class="headerlink" title="常用键盘事件"></a>常用键盘事件</h4><ul><li><p><code>keyup</code>:按键弹起时触发</p></li><li><p><code>keydown</code>: 按键按下时触发</p></li><li><p><code>keypress</code>: 按键上下弹起的分界点时触发</p></li></ul><p>注意</p><ol><li><p>对于传统事件注册记得加 on</p></li><li><p><code>keypress</code> 无法识别 <code>ctrl</code>、<code>shift</code> 等功能键</p></li><li><p>三个时间执行顺序 <code>keydown -&gt; keypress -&gt; keyup</code></p></li></ol><blockquote><p>键盘事件对象</p></blockquote><p><code>e.keyCode</code>: 返回所按的键的ASCII值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;keyup&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; 		</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;keyup&#x27;</span>+e.keyCode); 		</span><br><span class="line">    <span class="keyword">if</span>(e.keyCode == <span class="number">65</span>)&#123; 			</span><br><span class="line">        alert(<span class="string">&#x27;您按下了a键&#x27;</span>); 		</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; 			</span><br><span class="line">        alert(<span class="string">&#x27;您没有按下a键&#x27;</span>); 		</span><br><span class="line">    &#125; 		</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意:</p><ol><li><p><code>keyup</code> 和 <code>keydown</code> 的 <code>keyCode</code> 不区分大小写 得到的都是大写的值</p></li><li><p><code>keypress</code> 的 <code>keyCode</code> 区分大小写</p></li><li><p><code>keydown</code> 和 <code>keypress</code> 在文本框里的特点: 两个事件触发时,文字还没落入文本框中</p></li></ol><blockquote><p>滚动事件</p></blockquote><p><code>element.onscroll</code>: 元素滚动时发生</p><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><blockquote><p>Browser Object model 浏览器对象模型,提供了独立于内容而与浏览器窗口进行交互的对象,核心为 window</p></blockquote><p>特点: BOM 由一系列相关的对象组成,并且每个对象提供了很多方法与属性。BOM 缺乏标准,js 语法的标准化组织是 ECMA,DOM 的标准化组织是 W3C,BOM 最初始 Netscape 浏览器标准的一部分</p><blockquote><p>DOM</p></blockquote><ul><li>文档对象</li><li>DOM就是把[<code>文档</code>]当做一个[<code>对象</code>]来看待</li><li>DOM主要学习的是操作页面元素</li><li>DOM是W3C标准规范</li></ul><blockquote><p>BOM</p></blockquote><ul><li>浏览器对象模型</li><li>把[<code>浏览器</code>]当作一个[<code>对象</code>]来看待</li><li>BOM的顶级对象是window</li><li>BOM学习是浏览器窗口交互的一些对象</li><li>BOM是浏览器厂商在各自浏览器窗口交互的一些对象</li><li>BOM是浏览器厂商在各自浏览器上定义的,兼容性较差</li></ul><blockquote><p>BOM的构成</p></blockquote><p>Window 是浏览器的顶级对象,被 window 属性引用,代表是一个 web 浏览器窗口。它具有双重角色</p><ol><li><p>它是 JS 访问浏览器窗口的一个接口</p></li><li><p>它是全局对象,定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法</p></li><li><p>document 是 window 最重要的属性之一,它是 DOM 的顶级对象</p></li></ol><p>调用的时候可以省略 window</p><p>注意: window 有一个特殊属性 window.name 命名变量时不要用 name</p><p><img src="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/20200429204106.png"></p><h4 id="Window常见事件"><a href="#Window常见事件" class="headerlink" title="Window常见事件"></a>Window常见事件</h4><ul><li><p>页面加载事件</p><p><code>window.onload = function()&#123;&#125;</code></p><p><code>window.addEventListener(&#39;load&#39;,function()&#123;&#125;)</code></p><p>当文档内容<code>完全加载完成会触发该事件(包括图像、脚本文件、CSS文件等)</code>,使用这个事件就可将script放在任意位置不影响执行</p><p><code>document.addEventListener(&#39;DOMContentLoaded&#39;,function()&#123;&#125;)</code></p><p>当文档内容<code>不完全加载完成会触发该事件(不包括图像、flash、CSS文件等)</code>,速度较上两者<code>较快</code></p></li><li><p>调整窗口大小事件</p><p><code>window.onresize = function()&#123;&#125;</code></p><p><code>window.addEventListener(&#39;resize&#39;,function()&#123;&#125;);</code></p><p>当窗口大小发生变化时触发事件,常用于响应式布局</p></li><li><p>屏幕当前宽度</p><ol><li><p><code>window.innerWidth</code></p></li><li><p><code>window.innerHeight</code></p></li></ol></li><li><p>实现屏幕滚动</p><p><code>window.scroll(x,y)</code>: x,y为横向、纵向滚动的距离(<code>不加单位</code>)</p></li><li><p>禁止双击选中文字</p><p><code>window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();</code></p></li><li><p>定时器</p><p><code>window.setTimeout(调用函数,延迟时间);</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="string">&#x27;111&#x27;</span>); </span><br><span class="line">&#125;,<span class="number">2000</span>); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;爆炸了&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">setTimeout</span>(callback,<span class="number">3000</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&#x27;callback()&#x27;</span>,<span class="number">3000</span>); </span><br><span class="line"><span class="keyword">var</span> time1 = <span class="built_in">setTimeout</span>(callback,<span class="number">1000</span>); </span><br><span class="line"><span class="keyword">var</span> time2 = <span class="built_in">setTimeout</span>(callback,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>注意:</p><ol><li><p>延迟时间单位为毫秒 可以不写 默认为 0</p></li><li><p>这个调用函数可以直接写函数 也可以写 函数名 也可以 ‘函数名()’</p></li><li><p>window 可以省略</p></li><li><p>页面中可能有多个定时器 一般要起标识符</p></li><li><p>因为 setTimeout 是倒计时完再回调函数,所以也叫作回调函数</p></li></ol><p><code>window.setInterval(调用函数,延迟时间);</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>); 	</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>注意: 其他都和 setTimeout 相同,但是 setTimeout 只调用函数一次,而 setInterval 是每隔设定间隔时间就调用一次,常用于倒计时</p></li><li><p>清除倒计时</p><p><code>window.clearTimeout(定时器的名字)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn  = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>); 	</span><br><span class="line"><span class="keyword">var</span> timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;爆炸&#x27;</span>); 	</span><br><span class="line">&#125;,<span class="number">5000</span>); 	</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>window.clearInterval(定时器名字)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>; 	</span><br><span class="line"><span class="keyword">var</span> begin = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.begin&#x27;</span>); 	</span><br><span class="line"><span class="keyword">var</span> stop = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.stop&#x27;</span>); 	 </span><br><span class="line">begin.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 			</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello?&#x27;</span>); 		</span><br><span class="line">    &#125;,<span class="number">1000</span>)	</span><br><span class="line">&#125;)	</span><br><span class="line">stop.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer); 	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意:函数内定时器赋予名字时最好现在外面建立全局变量,以便清除</p></li></ul><h4 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h4><ol><li><p>全局作用域或者普通函数中this指向全局对象 window(setTimeout、setInterval也是)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);  		</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); 	</span><br><span class="line">&#125; 	</span><br><span class="line">fn(); 	</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); 	</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>方法调用中指向调用方法者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">    sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);  <span class="comment">//指向o 因为这个函数是o的  </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; 	</span><br><span class="line">o.sayHi(); </span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//指向btn </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>构造函数this指向构造函数的实例(谁创建指向谁)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);  <span class="comment">//指向fun()</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> Fun();</span><br></pre></td></tr></table></figure></li></ol><h4 id="JS的执行队列-非常重要"><a href="#JS的执行队列-非常重要" class="headerlink" title="JS的执行队列(非常重要)"></a>JS的执行队列(非常重要)</h4><blockquote><p>JavaScript的一大特点即<code>单线程</code>,即<code>同一时间只能做一件事</code></p></blockquote><p>JS有同步和异步</p><ul><li><p>同步: 即按顺序执行任务,前一个任务结束再执行另一个</p></li><li><p>异步: 执行一件任务的同时可以执行其他任务</p></li></ul><p>JS执行机制 - 分为<code>同步任务</code>和<code>异步任务</code></p><ul><li><p>同步任务: 都放到主线程上执行,形成一个<code>执行栈</code></p></li><li><p>异步任务: JS的异步是通过<code>回调函数</code>实现的</p></li></ul><p>异步任务三种类型:</p><ol><li><p>普通事件 如: click , resize , readystatechange 等</p></li><li><p>资源加载 如 load , error 等</p></li><li><p>定时器中的回调函数</p></li></ol><p>异步任务的相关回调函数添加到任务队列中(消息队列)</p><p><img src="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/20200429210903.png"></p><p><code>执行过程</code>:</p><ol><li><p>先执行执行栈中的同步任务</p></li><li><p>遇到异步任务触发则将其回调函数放到任务队列中</p></li><li><p><code>等所有同步任务执行完毕后,再回去按序执行任务队列中的回调函数</code></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/20200429211003.png"></p><p>异步进程处理: <code>用于检测异步任务是否被触发(比如点击,倒计时时间到等),一旦触发,就将其放入任务队列中。执行栈的同步任务全部执行完后,就会到任务队列查看是否有未执行的异步任务,一旦有则将其执行,全部执行完后会不断查看不断执行,形成 事件循环。</code></p><h4 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h4><blockquote><p>window 的 location 属性引用了 Location 对象,用于获取 URL 相关属性</p></blockquote><p><code>URL::统一资源定位符</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">URL的一般语法格式为: </span><br><span class="line"></span><br><span class="line">protocol:&#x2F;&#x2F;host[:port]&#x2F;path&#x2F;[?query]#fragment</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;zykjofficial.gitee.io&#x2F;index.html?name&#x3D;zykj&amp;age&#x3D;18#link</span><br></pre></td></tr></table></figure><ul><li><p><code>protocol</code>: 协议, http , ftp , maito 等</p></li><li><p><code>host</code>: 主机(域名) <code>[www.xxxx.com](http://www.xxxx.com)</code></p></li><li><p><code>port</code>: 端口号 可选,省略时使用方案的默认端口 如http的默认端口为80</p></li><li><p><code>path</code>: 路径 由零个或多个<code>/</code>符号隔开的字符串,一般用来表示主机上的一个目录或文件</p></li><li><p><code>query</code>: 参数 以键值对的形式通过<code>&amp;</code>符号分隔开</p></li><li><p><code>fragment</code>: 片段,<code>#</code>后面内容 一般用于链接锚点</p></li></ul><p><code>location 对象的属性</code></p><table><thead><tr><th>location对象属性</th><th>返回值</th></tr></thead><tbody><tr><td><code>location.href</code></td><td>获取或者设置整个URL</td></tr><tr><td><code>location.host</code></td><td>返回主机(域名) zykjofficial.gitee.io</td></tr><tr><td><code>location.port</code></td><td>返回端口号 如果写返回 空字符串</td></tr><tr><td><code>location.pathname</code></td><td>返回路径</td></tr><tr><td><code>location.search</code></td><td>返回参数</td></tr><tr><td><code>location.hash</code></td><td>返回片段 #后面内容 常见于链接 锚点</td></tr></tbody></table><p><code>location另外几个属性</code></p><ul><li><p><code>location.assign</code>: 与href一样,实现页面跳转</p></li><li><p><code>location.replace</code>: 实现页面跳转,但是没有后退功能</p></li><li><p><code>location.reload</code>: 刷新页面 等于 f5</p></li><li><p><code>location.reload(true)</code>: 强制刷新</p></li><li><p><code>location = &quot;#xx&quot;</code>: 可以使页面滚动到 id 为 xx 的元素的位置</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>); </span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="comment">//assign 与href一样,实现跳转 </span></span><br><span class="line">    location.assign(<span class="string">&#x27;http://www.baidu.com&#x27;</span>);</span><br><span class="line">    <span class="comment">//实现跳转 但是不记录历史 没有退回功能</span></span><br><span class="line">    <span class="comment">// location.replace(&#x27;http://www.baidu.com&#x27;); </span></span><br><span class="line">    <span class="comment">//重新加载刷新  等于f5 </span></span><br><span class="line">    location.reload(<span class="string">&#x27;http://www.baidu.com&#x27;</span>); </span><br><span class="line">    location.reload(<span class="literal">true</span>); <span class="comment">//强制刷新 Ctrl + F5</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> 	</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> 	</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> 	</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> 	</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> 	</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> 	</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> 	</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> 	</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> 	</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> 	</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;last&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> 	</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span> 		</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#last&quot;</span>); 		</span></span><br><span class="line"><span class="javascript">        div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 			</span></span><br><span class="line"><span class="javascript">            location = <span class="string">&quot;#one&quot;</span>; 		</span></span><br><span class="line">        &#125; 	</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h4><blockquote><p>window 的 navigator 属性引用的是 Navigator 对象。最常用的属性为 userAgent ,该属性可以返回有客户机发送服务机的 user-agent 头部的值</p></blockquote><p>下列代码可以判断用户哪个终端打开页面,实现跳转</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断用户哪个终端打开页面,实现跳转 </span></span><br><span class="line"><span class="keyword">if</span>((navigator.userAgent.match(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry| IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>)))&#123; 		</span><br><span class="line"><span class="built_in">window</span>.location.href = <span class="string">&quot;&quot;</span>; <span class="comment">//手机端打开页面 	</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; 		</span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">&quot;&quot;</span>; </span><br><span class="line">    <span class="comment">//电脑端打开页面 	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h4><blockquote><p>window 对象给我们提供了一个 history 属性,该属性引用了 History 对象。可以与浏览器历史记录进行交互。该对象包含用户(在浏览器窗口中)访问过的 URL</p></blockquote><table><thead><tr><th>history对象方法</th><th>作用</th></tr></thead><tbody><tr><td><code>back()</code></td><td>可以后退功能</td></tr><tr><td><code>forward()</code></td><td>前进功能</td></tr><tr><td><code>go(参数)</code></td><td>前进后退功能 参数如果是1 前进1个页面 如果是-1 后退1个页面</td></tr><tr><td><code>pushState(state, title, url)</code></td><td>向浏览器历史添加了一个状态。pushState()方法带有三个参数：一个状态对象、一个标题(现在被忽略了)以及一个可选的URL地址</td></tr><tr><td><code>history.replaceState(state, title, url)</code></td><td>修改当前历史记录条目而并非创建新的条目</td></tr></tbody></table><p><code>history.forward()</code>: 实现前进功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    history.forward();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>history.back</code>: 实现后退功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    history.back(); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>history.go(参数)</code>: 实现前进或后退功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    history.go(<span class="number">1</span>); <span class="comment">// 前进一页     </span></span><br><span class="line">    history.go(<span class="number">-1</span>); <span class="comment">// 后退一页 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>history.pushState()</code>：向浏览器历史添加了一个状态。pushState()方法带有三个参数：一个状态对象、一个标题(现在被忽略了)以及一个可选的URL地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(state, title, url);</span><br><span class="line"></span><br><span class="line">state object —— 状态对象是一个由pushState()方法创建的、与历史纪录相关的javascript对象。当用户定向到一个新的状态时，会触发</span><br><span class="line"></span><br><span class="line">popstate事件。事件的state属性包含了历史纪录的state对象。如果不需要这个对象，此处可以填null</span><br><span class="line"></span><br><span class="line">title —— 新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null</span><br><span class="line"></span><br><span class="line">URL —— 这个参数提供了新历史纪录的地址。新URL必须和当前URL在同一个域，否则，pushState()将丢出异常。这个参数可选，如果它没有被特别标注，会被设置为文档的当前URL</span><br></pre></td></tr></table></figure><p>假定当前网址是example.com/1.html，使用pushState方法在浏览记录(history对象)中添加一个新记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stateObj &#x3D; &#123; foo: &#39;bar&#39; &#125;;</span><br><span class="line">history.pushState(stateObj, &#39;page 2&#39;, &#39;2.html&#39;);</span><br></pre></td></tr></table></figure><p>添加上面这个新记录后，浏览器地址栏立刻显示example.com/2.html，但并不会跳转到2.html，甚至也不会检查2.html是否存在，它只是成为浏览历史中的最新记录。假如这时访问了google.com，然后点击了倒退按钮，页面的url将显示2.html，但是内容还是原来的1.html。再点击一次倒退按钮，url将显示1.html，内容不变</p><ul><li><p>总之，pushState方法不会触发页面刷新，<code>只是导致history对象发生变化，地址栏的显示地址发生变化</code></p></li><li><p>如果pushState的url参数，设置了一个新的锚点值(即hash)，并不会触发hashchange事件，即使新的URL和旧的只在hash上有区别</p></li><li><p>如果设置了一个跨域网址，则会报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&#x27;https://twitter.com/hello&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><p><code>history.replaceState</code>:方法的参数与pushState方法一模一样，不同之处在于replaceState()方法会修改当前历史记录条目而并非创建新的条目</p><p>假定当前网页是example.com/example.html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;title 1&#x27;</span>, <span class="string">&#x27;?page=1&#x27;</span>);</span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;title 2&#x27;</span>, <span class="string">&#x27;?page=2&#x27;</span>);</span><br><span class="line">history.replaceState(&#123;<span class="attr">page</span>: <span class="number">3</span>&#125;, <span class="string">&#x27;title 3&#x27;</span>, <span class="string">&#x27;?page=3&#x27;</span>);</span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line"><span class="comment">// url显示为http://example.com/example.html?page=1</span></span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line"><span class="comment">// url显示为http://example.com/example.html</span></span><br><span class="line"></span><br><span class="line">history.go(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// url显示为http://example.com/example.html?page=3</span></span><br></pre></td></tr></table></figure><p>注: history 对象一般在实际开发中比较少用,但在一些办公OA系统会见到</p><ul><li><p>无干扰的 JavaScript</p><blockquote><p>这种模式强调 JavaScript 自身不应该惹人注意,不应该产生打扰。不应该去干扰用户浏览一个 web 页面,不应该干扰内容作者创建 HTML 标记,或者干扰 Web 设计者创建 HTML 模板或 CSS 样式表</p></blockquote></li><li><p>方法</p><ol><li>分离: 保持 JavaScript 代码与HTML标记的分离。尽可能让 JavaScript 代码的外部文件成为模块</li><li>降级: 必须降低优雅性。JavaScript 模块应该首先确保它所需要的客户端功能在代码所运行的浏览器中是可用的</li><li>不能降低一个 HTML 页面的可访问性.JS 的角色是增加信息的表现力而不是负责信息的表现。为了实现可访问性,应该尽可能支持独立于设备的事件(onfocus、onchange等)。</li></ol></li></ul><h3 id="网页特效-PC端"><a href="#网页特效-PC端" class="headerlink" title="网页特效-PC端"></a>网页特效-PC端</h3><h4 id="offset系列"><a href="#offset系列" class="headerlink" title="offset系列"></a>offset系列</h4><blockquote><p>元素偏移量offset: 可以动态的获取元素的位置、大小等</p></blockquote><h5 id="offset系列常用属性"><a href="#offset系列常用属性" class="headerlink" title="offset系列常用属性"></a>offset系列常用属性</h5><table><thead><tr><th>offset系列属性</th><th>作用</th></tr></thead><tbody><tr><td><code>elememt.offsetParent</code></td><td>返回作为该元素<code>带有定位的父级元素</code> 如果父级都没有定位则返回body</td></tr><tr><td><code>element.offsetTop</code></td><td>返回元素相对带有定位父元素上方的偏移</td></tr><tr><td><code>element.offsetLeft</code></td><td>返回元素相对带有定位父元素左边框的偏移</td></tr><tr><td><code>element.offsetWidth</code></td><td>返回自身包括padding、边框、内容区的宽度，返回数值不带单位</td></tr><tr><td><code>element.offsetHeight</code></td><td>返回自身包括paddling、边框、内容区的高度，返回数值不带单位</td></tr></tbody></table><p>注意：</p><ol><li><p>返回的数值没有单位</p></li><li><p>offsetParent返回的不一定是亲父亲，而是最近的<code>带有定位</code>的父级元素。parentNode返回的是亲父亲且不管有没有定位</p></li></ol><h5 id="offset与style区别"><a href="#offset与style区别" class="headerlink" title="offset与style区别"></a>offset与style区别</h5><p><strong>offset</strong></p><ul><li>offset 可以得到任意样式表中的样式值</li><li>offset 系列获得的数值是没有单位的</li><li>offsetWidth 包含padding + border + width</li><li>offsetWidth 等属性是只读属性,只能获取不能赋值</li><li><code>所以， 我们想要获取元素大小位置,用offset更合适</code></li></ul><p><strong>style</strong></p><ul><li>style 只能得到行内样式表中的样式值</li><li>style.width获得的是带有单位的字符串</li><li>style.width获得不包含padingRaborder 的值</li><li>style.width 是可读写属性,可以获取也可以赋值</li><li>所以， 我们想要给元素更改值,则需要用style改变</li></ul><h4 id="client系列"><a href="#client系列" class="headerlink" title="client系列"></a>client系列</h4><blockquote><p>通过client的相关属性可以动态获取该元素的边框大小,元素大小等</p></blockquote><table><thead><tr><th>client</th><th>作用</th></tr></thead><tbody><tr><td><code>element.clientTop</code></td><td>返回元素上边框的大小</td></tr><tr><td><code>element.clientLeft</code></td><td>返回元素左边框的大小</td></tr><tr><td><code>element.clientWidth</code></td><td>返回自身包括padding,内容区宽度,不包含边框</td></tr><tr><td><code>element.clientHeight</code></td><td>返回自身包括padding,内容区高度,不包含边框</td></tr></tbody></table><h4 id="事件对象之offsetX-Y"><a href="#事件对象之offsetX-Y" class="headerlink" title="事件对象之offsetX/Y"></a>事件对象之offsetX/Y</h4><p>offsetX 规定了事件对象与目标节点的内填充边（padding edge）在 X 轴方向上的偏移量。</p><p>比如在元素内触发点击事件时点击位置距离元素右边距的距离</p><h4 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h4><blockquote><p>主要作用: 创建一个独立的作用域，避免了命名冲突问题</p></blockquote><p>两种写法</p><ol><li><p><code>(function(形参) &#123;&#125;)(实参)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(a+b); </span><br><span class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>); </span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><code>(function(形参) &#123;&#125; (实参) )</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(a-b);</span><br><span class="line">&#125; (<span class="number">3</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure></li></ol><h4 id="scroll系列"><a href="#scroll系列" class="headerlink" title="scroll系列"></a>scroll系列</h4><blockquote><p>通过scroll可以动态获取该元素的大小,滚动距离等</p></blockquote><table><thead><tr><th>scroll</th><th>作用</th></tr></thead><tbody><tr><td><code>element.scrollTop</code></td><td>返回被卷去的上侧距离</td></tr><tr><td><code>element.scrollLeft</code></td><td>返回被卷去的左侧距离</td></tr><tr><td><code>element.scrollWidth</code></td><td>返回自身实际的宽度,不含边框,包含padding</td></tr><tr><td><code>element.scrollHeight</code></td><td>返回自身实际的高度,不含边框,包含padding</td></tr></tbody></table><p>页面被卷曲的头部</p><p>页面被卷去的头部兼容性解决方案</p><p>需要注意的是,页面被卷去的头部，有兼容性问题， 因此被卷去的头部通常有如下几种写法:</p><ol><li><p>声明了DTD ,使用<code>document.documentElement.scrollTop</code></p></li><li><p>未声明DTD ,使用<code>document.body.scrollTop</code></p></li><li><p>新方法<code>window.pageYoffset</code>和window.pageXoffset，IE9开始支持</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		left: <span class="built_in">window</span>.pageXoffset || <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft || <span class="number">0</span>,</span><br><span class="line">		top: <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop || <span class="number">0</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用的时候 getScroll().left*/</span></span><br></pre></td></tr></table></figure><p>重点是<code>window.pageYoffset</code> 和<code>window.pageXoffset</code></p><h4 id="三大系列总结"><a href="#三大系列总结" class="headerlink" title="三大系列总结"></a>三大系列总结</h4><p><img src="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/20200514221416.png"></p><p>用途</p><ul><li><p><code>element.offsetTop(offsetLeft)</code>: 获取元素位置</p></li><li><p><code>element.clientWidth(clientHeight)</code>: 获取元素大小</p></li><li><p><code>element.scrollTop(scrollLeft)</code>: 获取元素滚动距离</p></li><li><p><code>window.pageXOffset(pageYOffset)</code>: 获取页面滚动距离</p></li></ul><p>总结：</p><ul><li><p><code>element.offsetLeft/Top</code>: 获取元素相对于最近的有定位的父元素的坐标，如果没有有定位的父元素，则是文档坐标</p></li><li><p><code>element.scrollTop/Left</code>: 获取元素滚动卷去的距离</p></li><li><p><code>element.offsetWidth/Height</code>: 获取元素的宽度高度（包含边框）</p></li><li><p><code>element.clientWidth/Height</code>: 获取元素的宽度高度（不包含边框）</p></li><li><p><code>element.scrollWidth/Height</code>: 获取元素的内容宽度高度（包括被卷曲的部分）</p></li><li><p><code>e.pageX/Y 获取鼠标的文档坐标</code>:（相对于文档而言）</p></li><li><p><code>e.clientX/Y</code>: 获取鼠标的视口坐标（相对于视口而言）</p></li><li><p><code>e.screenX/Y</code>: 获取鼠标的屏幕坐标（相对于整个浏览器而言）</p></li><li><p><code>window.pageY/XOfffset</code>: 获取页面的滚动距离</p></li></ul><h4 id="mouseover-mouseenter"><a href="#mouseover-mouseenter" class="headerlink" title="mouseover/mouseenter"></a>mouseover/mouseenter</h4><blockquote><p>mouseover和mouseenter的区别</p></blockquote><p>mouseover会冒泡，mouseenter不会冒泡 与之对应的mouseleave也不会冒泡</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span> 	</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> 	</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> father = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.father&#x27;</span>); </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> son = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>); 						</span></span><br><span class="line"><span class="javascript">    father.addEventListener(<span class="string">&#x27;mouseenter&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; 		</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>); </span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：如果是<code>mouseenter</code>则经过父盒子本身才会触发，<code>mouseover</code>经过父盒子和子盒子都会触发</p><h3 id="动画函数"><a href="#动画函数" class="headerlink" title="动画函数"></a>动画函数</h3><p>核心原理: 通过定时器setInterval()不断移动盒子距离</p><blockquote><p>缓动动画：即动画速度有所变化的动画</p></blockquote><p><code>逐渐变慢实现原理：每次的移动距离都下降（= （目标距离-移动距离）/定值）</code></p><p>每次移动的距离应该取整，如果是正值则往大了取，因为最后面如果往小取会等于0停止移动，负值同理</p><p><code>解决多次点击按钮速度变快的方法：每次调用定时器时先清除之前的定时器</code></p><p><code>回调函数写在清除定时器之后</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓动动画函数封装obj目标对象target目标位置</span></span><br><span class="line"><span class="comment">//思路:</span></span><br><span class="line"><span class="comment">// 1.让盒子每次移动的距离慢慢变小， 速度就会慢慢落下来。</span></span><br><span class="line"><span class="comment">// 2.核心算法: (目标值-现在的位置) / 10做为每次移动的距离步长</span></span><br><span class="line"><span class="comment">// 3.停止的条件是:让当前盒子位置等于目标位置就停止定时器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">obj,target,callback</span>) </span>&#123; </span><br><span class="line">    <span class="comment">//先清除以前的定时器，只保留当前的个定时器执行</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">    <span class="comment">//为每个对象添加一个定时器</span></span><br><span class="line">    obj.timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="comment">//设置步长(移动距离) 步长值写到定时器的里面</span></span><br><span class="line">        <span class="comment">//把我们步长值改为整数不要出现小数的问题</span></span><br><span class="line">	<span class="keyword">var</span> step = ((target-obj.offsetLeft)/<span class="number">10</span>)&gt;<span class="number">0</span>? <span class="built_in">Math</span>.ceil((target-obj.offsetLeft)/<span class="number">10</span>):<span class="built_in">Math</span>.floor((target-obj.offsetLeft)/<span class="number">10</span>); 			</span><br><span class="line">        <span class="keyword">if</span>(obj.offsetLeft == target) &#123; </span><br><span class="line">            <span class="comment">//停止动画本质是停止定时器</span></span><br><span class="line">            <span class="built_in">clearInterval</span>(obj.timer); 		</span><br><span class="line">            <span class="comment">//if(callback) &#123; 			</span></span><br><span class="line">            <span class="comment">//    callback(); 		</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            callback &amp;&amp; callback(); <span class="comment">//这样写更简单  		</span></span><br><span class="line">        &#125; 		</span><br><span class="line">        <span class="comment">//匀速动画 		</span></span><br><span class="line">        <span class="comment">// obj.style.left = obj.offsetLeft + 1 + &#x27;px&#x27;; 	</span></span><br><span class="line">        <span class="comment">//缓动动画 </span></span><br><span class="line">        <span class="comment">//把每次加1这个步长值改为一个慢慢变小的值 步长公式: (目标值-现在的位置) / 10</span></span><br><span class="line">        obj.style.left = obj.offsetLeft + step + <span class="string">&#x27;px&#x27;</span>; 	</span><br><span class="line">&#125;,<span class="number">30</span>)&#125;;	</span><br></pre></td></tr></table></figure><h3 id="节流阀"><a href="#节流阀" class="headerlink" title="节流阀"></a>节流阀</h3><blockquote><p>防止轮播图按钮连续点击过快</p></blockquote><p>当上一个动画执行完毕后再允许执行下一次，让事件无法连续触发</p><p>核心思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数</p><p>即：</p><ol><li><p>先设置一个变量为true</p></li><li><p>当变量为true时执行事件，并将变量改为false，关闭水龙头</p></li><li><p>利用回调函数在事件结束后将变量改为true，打开水龙头</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行的函数</span></span><br><span class="line"></span><br><span class="line">animate(obj,target,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  flag = <span class="literal">true</span>;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h3><blockquote><p>客户端存储的形式</p></blockquote><ol><li>web存储(包含 localStorage 和 sessionStorage 两个 API)</li><li>cookie</li><li>IE User Data</li><li>离线 Web 应用</li><li>Web 数据库</li><li>文件系统 API</li></ol><blockquote><p>客户端存储的特性</p></blockquote><p>客户端存储遵循同源策略,因此不同站点的页面是无法互相读取对方存储的数据,而同一站点的不同页面之间是可以互相共享存储数据的</p><p>任何形式的客户端都不应该用来保存密码,商业账号或者其他类似的敏感信息</p><ol><li><p>web存储</p><p><code>web存储特性</code></p><ul><li><p>数据存储在用户浏览器中</p></li><li><p>设置、读取方便</p></li><li><p>容量较大, sessionStorage 约 5M,localStorage 约 20M</p></li><li><p>只能存储字符串</p></li></ul><p><code>window.localStorage 本地存储</code></p><ul><li>生命周期为永久性的,除非人为删除</li><li>作用域限定在文档源中(文档源是通过协议、主机、端口号三者确定的),同源的 localStorage 可以互相读取对方数据,非同源文档则不可以(只要协议、主机、端口号有一个不同就是非同源文档)</li><li>作用域也受浏览器供应商限制</li><li>键值对形式存储</li></ul><p><code>Window.sessionStorage 临时存储</code></p><ul><li><p>生命周期为关闭窗口或标签页</p></li><li><p>作用域也是限定在同源文档中。此外也被限定在窗口中,即使是同源文档,在不同的浏览器标签页打开也无法共享同个 seesionStorage 数据</p></li><li><p>以键值对的形式存储使用</p></li></ul><p><code>存储API</code></p><ul><li><p>存储数据: <code>sessionStorage.setItem(key,value)</code></p></li><li><p>获取数据: <code>sessionStorage.getItem(key)</code></p></li><li><p>删除数据: <code>sessionStorage.removeItem(key)</code></p></li><li><p>删除所有数据: <code>sessionStorage.clear()</code></p><hr></li><li><p>存储数据: <code>localStorage.setItem(key,value)</code></p></li><li><p>获取数据: <code>localStorage.getItem(key)</code></p></li><li><p>删除数据: <code>localStorage.removeItem(key)</code></p></li><li><p>删除所有数据: <code>LocalStorage.clear()</code></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加某个数据 </span></span><br><span class="line">set.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> val = ipt.value; </span><br><span class="line">    sessionStorage.setItem(<span class="string">&#x27;unmame&#x27;</span>,val); </span><br><span class="line">    sessionStorage.setItem(<span class="string">&#x27;pwd&#x27;</span>,val); </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//获得某个数据 </span></span><br><span class="line">get.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;		 		</span><br><span class="line">    <span class="built_in">console</span>.log(sessionStorage.getItem(<span class="string">&#x27;unmame&#x27;</span>)); </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//删除指定数据 </span></span><br><span class="line">remove.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    sessionStorage.removeItem(<span class="string">&#x27;unmame&#x27;</span>); </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//删除所有数</span></span><br><span class="line">del.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    sessionStorage.clear();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>cookie (指 web 存储的少量数据)</p><p>特点:</p><ul><li><p>cookie 数据会自动在 Web 浏览器和 Web 服务器之间传输</p></li><li><p>兼容性好</p></li><li><p>所有查询设置删除都要通过 Document 对象的 cookie 属性完成</p></li><li><p>通过 navigator.cookieEnabled 来检查 cookie 是否启用</p></li></ul><p><code>cookie的属性: 有效期和作用域</code></p><blockquote><p>有效期: cookie 的默认有效期很短,浏览器一旦关闭 cookie 保存的数据就丢失了。但是不是和 sessionStorage 相同,cookie 是整个浏览器关掉才会消失,而 sessionStorage 是标签页关掉则销毁该标签页的数据其他不影响。可以通过max-age 属性(单位为秒)设置有效期。</p></blockquote><blockquote><p>作用域: cookie 作用域由文档源和文档路径限制。一个页面的 cookie 可以和文档与其同个目录或者是其子目录的页面共享。</p></blockquote><p>如: <code>http://www.baidu.com/catalog/index.html</code>创建了一个 cookie ,那么该 cookie 对 <code>http://www.baidu.com/catalog/order.html</code> 或 <code>http://www.baidu.com/catalog/xxx/index.html</code> 都是可见的。可以通过修改cookie 的属性 path 来修改 cookie 的路径。</p><p>如: <code>http://www.baidu.com/catalog/xxx/index.html</code> 创建了 cookie,如果把 path 改为”/catalog”,那么该 cookie 对 <code>http://www.baidu.com/catalog/widget/index.html</code> 也是可见的</p><p><code>cookie的API</code></p><ul><li><p>保存 cookie: 将cookie属性值设置为 name = value 格式的字符串</p><p>如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;version = &quot;</span> + <span class="built_in">encodeURIComponent</span>(<span class="built_in">document</span>.lastModified);</span><br></pre></td></tr></table></figure></li></ul><p>注意: cookie 中的值不允许包含分号逗号空白符,所以要在存储前对数据进行编码。相应的,读取时也要对获取的数据解码</p><p>同样可以设置 cookie的 path、domain、secure 等属性,只需将以下字符串形式追加在 cookie 值后面:</p><p><code>;path = path</code></p><p><code>;domian = domain</code></p><p><code>;secure</code></p><p>如果要改变新 cookie 的值,就需要用相同的名字路径和域但是不同的值来设置 cookie 的值,如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;version = &quot;</span> + <span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;new value&#x27;</span>);<span class="comment">//更改version的值</span></span><br></pre></td></tr></table></figure><p>要删除 cookie,就需要用相同的名字路径和域但是任意一个非空的值再次设置 cookie</p><ul><li>读取 cookie: 利用<code>document.cookie</code>读取,返回值为字符串,一般会先用split分开,然后解码,再利用<code>JSON.parse()方</code>法还原成json对象</li></ul></li><li><p>IE userData(通过在 document 元素后面附加一个专属的 “DHTML行为” 实现客户端存储)</p><p>步骤:</p><ol><li><p>对元素附加 userData 行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.style.behavior = <span class="string">&quot;url(&#x27;#default#userData&#x27;)&quot;</span>;</span><br></pre></td></tr></table></figure><p>此时的元素拥有 save() , load() 方法,接下来就可以通过元素的属性来访问这些名/值对形式的数据</p></li><li><p>通过 getAttribute、setAttribute 存储获取userData数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储 </span></span><br><span class="line">div.setAttribute(<span class="string">&quot;index&quot;</span>,<span class="number">1</span>); </span><br><span class="line">div.save(<span class="string">&quot;myindex&quot;</span>); </span><br><span class="line"><span class="comment">//读取 </span></span><br><span class="line">div.load(<span class="string">&quot;myindex&quot;</span>); </span><br><span class="line">div.getAttribute(<span class="string">&quot;index&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>离线Web应用(允许Web应用将应用程序自身本地保存到用户的浏览器中)</p><blockquote><p>是将应用程序自身保存起来——应用程序所需运行的所有文件(HTML、CSS、JavaScript/图片等),不会随着用户清楚浏览器缓存而被清除</p></blockquote><p>基本步骤: 首先要准备一个清单: 包含了所有应用程序依赖的所有 URL 列表,然后通过 html 标签中设置 manifest 属性指向该清单文件即可</p><p>清单文件以<code>.appcache</code>作为文件扩展名。首行内容必须为”CACHE MANIFEST”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;以下是文件清单 </span><br><span class="line">myapp.html </span><br><span class="line">myapp.js </span><br><span class="line">myapp.css </span><br><span class="line">images&#x2F;background.png</span><br></pre></td></tr></table></figure><p>复杂的清单</p><p>清单文件中可以使用特殊的区域头来标识该头信息之后清单项的类型</p><p>上面都属于<code>&quot;CACHE:&quot;</code>区域,也是默认的区域</p><p>此外还有两种</p><ul><li><p><code>&quot;NETWORK&quot;</code>: 该区域标识了该 URL 中的资源从不缓存,都是从网络获取</p></li><li><p><code>&quot;FALLBACK&quot;</code>: 该区域中清单项每行都包含两个 URL ,第一个 URL 是一个前缀,任何能够匹配到该前缀的URL都不会缓存起来,但是可能的话,它们会从网络中载入。第二个 URL 是指需要加载和存储在缓存中的资源。如果从网络中载入这样一个 URL 失败的话。就会使用第二个 URL 指定的缓存资源来代替,从缓存中获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CHCHE MANIFEST </span><br><span class="line"></span><br><span class="line">CACHE:   </span><br><span class="line">	myapp.html   </span><br><span class="line">	myapp.css    </span><br><span class="line">	myapp.js     </span><br><span class="line"></span><br><span class="line">FALLBACK:    </span><br><span class="line">	video&#x2F; offline_help.html         </span><br><span class="line"></span><br><span class="line">NETWORK:    </span><br><span class="line">	cgi &#x2F; </span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>缓存的更新</p></blockquote><p>在线的状态下,浏览器会异步检查清单文件是否有更新。但只是检查清单文件,而不是检查清单文件里的资源是否有更新。想更新资源文件需要手动修改</p><p>想要卸载 APP 应用,则要在服务器端删除清单文件,使得请求该文件的时候返回404无法找到的错误,同时,修改 HTML 文件 manifest 属性以便他们与该清单列表”断开连接”</p><h3 id="H5新增API"><a href="#H5新增API" class="headerlink" title="H5新增API"></a>H5新增API</h3><div class="note info flat"><p>这里的知识需要 jquery</p></div><h4 id="检测网络连接状态"><a href="#检测网络连接状态" class="headerlink" title="检测网络连接状态"></a>检测网络连接状态</h4><h5 id="网络连接事件"><a href="#网络连接事件" class="headerlink" title="网络连接事件"></a>网络连接事件</h5><p><code>online 当网络连接时触发</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;online&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    $(<span class="string">&quot;.tips&quot;</span>).text(<span class="string">&quot;网络已经连接&quot;</span>).fadeIn(<span class="number">500</span>).delay(<span class="number">1000</span>).fadeOut(<span class="number">500</span>); 	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="网路断开事件"><a href="#网路断开事件" class="headerlink" title="网路断开事件"></a>网路断开事件</h5><p><code>offline 网络断开时触发</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;offline&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</span><br><span class="line">    $(<span class="string">&quot;.tips&quot;</span>).text(<span class="string">&quot;网络已经断开&quot;</span>).fadeIn(<span class="number">500</span>).delay(<span class="number">1000</span>).fadeOut(<span class="number">500</span>); 	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="全屏显示"><a href="#全屏显示" class="headerlink" title="全屏显示"></a>全屏显示</h4><blockquote><p>全屏显示可以是任意元素,存在兼容性问题,包括高版本浏览器</p></blockquote><h5 id="请求全屏事件"><a href="#请求全屏事件" class="headerlink" title="请求全屏事件"></a>请求全屏事件</h5><blockquote><p>不同浏览器需要添加不同前缀</p></blockquote><p><code>xx.RequestFullScreen()</code></p><p><code>xxx.webkitRequestFullScreen()</code></p><p><code>xxx.mozRequestFullScreen()</code> 等等</p><p><code>ms的screen必须为小写</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(img.requestFullScreen)&#123;</span><br><span class="line">    img.requestFullScreen(); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(img.webkitRequestFullScreen)&#123; </span><br><span class="line">    img.webkitRequestFullScreen(); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(img.mozRequestFullScreen)&#123; </span><br><span class="line">    img.mozRequestFullScreen(); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(img.msRequestFullscreen)&#123;      <span class="comment">// ms 的screen的s必须小写  即img.msRequestFullscreen();</span></span><br><span class="line">    img.msRequestFullscreen();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="取消全屏"><a href="#取消全屏" class="headerlink" title="取消全屏"></a>取消全屏</h5><blockquote><p>跟元素没有关系,一般是用在 document 上,也要加浏览器前缀</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.CancelFullScreen();</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.webkitCancelFullScreen();</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.webkitCancelFullScreen();</span><br></pre></td></tr></table></figure><h5 id="检测是否全屏"><a href="#检测是否全屏" class="headerlink" title="检测是否全屏"></a>检测是否全屏</h5><blockquote><p>也是加在 document 上,也要加前缀</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.IsFullScreen();</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.webkitIsFullScreen();</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.webkitIsFullScreen();</span><br></pre></td></tr></table></figure><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><h5 id="FileReader对象"><a href="#FileReader对象" class="headerlink" title="FileReader对象"></a>FileReader对象</h5><blockquote><p>FileReader 对象: 允许 web 应用程序异步读取存储在用户计算机上的文件,比如一个 input 元素上选择文件后返回的对象</p></blockquote><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul><li><code>FileReader.result</code>: 用于读取文件的内容,仅在文件读取操作完成后有效,数据的格式取决于使用哪个方法(以下)来启动读取操作</li></ul><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul><li><p><code>FileReader.readAsDataURL(目标文件)</code>: 读取指定的文件的内容,返回 data:URL 格式的字符串(地址)存放在 result 属性中</p></li><li><p><code>FileReader.readAsText(目标文件)</code>: 读取指定文件的内容,以字符串格式返回文件内容到 result 属性中</p></li></ul><h5 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h5><p><code>FileReader.onload</code>: 该事件在读取完成时触发</p><p>file 类型 input 表单中有一个属性 files,以伪数组形式保存上传的文件信息,可以用 filereader 对象读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader.readAsDataURL(file.files[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>可以用 onchange 事件处理来检测 file 表单是否上传了文件</p><h4 id="video标签"><a href="#video标签" class="headerlink" title="video标签"></a>video标签</h4><p>属性</p><ul><li><p><code>video.duration</code>: 返回当前音频/视频的长度</p></li><li><p><code>currentTime</code>: 返回或设置当前音频/视频的播放进度</p></li></ul><p>事件</p><ul><li><p><code>video.oncanplay</code>: 当前视频/音频可以播放时触发</p></li><li><p><code>video.onended</code>: 当前视频/音频播放结束时触发</p></li><li><p><code>video.ontimeupdate</code>: 当前视频/音频播放位置改变时触发 通常与 currentTime 属性一起使用</p></li></ul><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><div class="note info flat"><p>思维导图来自: <a target="_blank" rel="noopener external nofollow noreferrer" href="https://gitee.com/jinsexiaozhima/jiujin/tree/master/Mindmap">https://gitee.com/jinsexiaozhima/jiujin/tree/master/Mindmap</a> 侵删！！！<br>更多文章 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.im/user/1626932942224398/posts">https://juejin.im/user/1626932942224398/posts</a></p></div><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><h4 id="前端发展史"><a href="#前端发展史" class="headerlink" title="前端发展史"></a>前端发展史</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%8F%B2.png"></p><h4 id="认识浏览器"><a href="#认识浏览器" class="headerlink" title="认识浏览器"></a>认识浏览器</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/2%E3%80%81%E8%AE%A4%E8%AF%86%E6%B5%8F%E8%A7%88%E5%99%A8.png"></p><h4 id="JS-基础知识"><a href="#JS-基础知识" class="headerlink" title="JS 基础知识"></a>JS 基础知识</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81JS%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.png"></p><h4 id="三类输出方式"><a href="#三类输出方式" class="headerlink" title="三类输出方式"></a>三类输出方式</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81%E4%B8%89%E7%B1%BB%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F.png"></p><h4 id="number数据类型"><a href="#number数据类型" class="headerlink" title="number数据类型"></a>number数据类型</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81number%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p><h4 id="string数据类型"><a href="#string数据类型" class="headerlink" title="string数据类型"></a>string数据类型</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/6%E3%80%81string%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p><h4 id="boolean数据类型"><a href="#boolean数据类型" class="headerlink" title="boolean数据类型"></a>boolean数据类型</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/7%E3%80%81boolean%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p><h4 id="object数据类型"><a href="#object数据类型" class="headerlink" title="object数据类型"></a>object数据类型</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/8%E3%80%81object%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p><h4 id="条件判断里的相互转换规则"><a href="#条件判断里的相互转换规则" class="headerlink" title="条件判断里的相互转换规则"></a>条件判断里的相互转换规则</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/9%E3%80%81%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E9%87%8C%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99.png"></p><h4 id="数据类型之间的区别-堆栈内存"><a href="#数据类型之间的区别-堆栈内存" class="headerlink" title="数据类型之间的区别(堆栈内存)"></a>数据类型之间的区别(堆栈内存)</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/10%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB(%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98).png"></p><h4 id="JS中三种常见的判断及判断中常用的散知识"><a href="#JS中三种常见的判断及判断中常用的散知识" class="headerlink" title="JS中三种常见的判断及判断中常用的散知识"></a>JS中三种常见的判断及判断中常用的散知识</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/11%E3%80%81JS%E4%B8%AD%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A4%E6%96%AD%E5%8F%8A%E5%88%A4%E6%96%AD%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%A3%E7%9F%A5%E8%AF%86.png"></p><h4 id="JS中三种常见的判断及判断中常用的散知识-1"><a href="#JS中三种常见的判断及判断中常用的散知识-1" class="headerlink" title="JS中三种常见的判断及判断中常用的散知识"></a>JS中三种常见的判断及判断中常用的散知识</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/12%E3%80%81JS%E4%B8%AD%E7%9A%84for%E5%BE%AA%E7%8E%AF.png"></p><h4 id="函数基础知识（全）"><a href="#函数基础知识（全）" class="headerlink" title="函数基础知识（全）"></a>函数基础知识（全）</h4><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/13%E3%80%81%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%85%A8%EF%BC%89.png">https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/原生JS篇/1、基础篇/13、函数基础知识（全）.png</a></p><h4 id="数组的基础知识"><a href="#数组的基础知识" class="headerlink" title="数组的基础知识"></a>数组的基础知识</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/14%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.png"></p><h4 id="数组中的常用方法"><a href="#数组中的常用方法" class="headerlink" title="数组中的常用方法"></a>数组中的常用方法</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/15%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png"></p><h4 id="数组常用方法补充reduce、filter、flat"><a href="#数组常用方法补充reduce、filter、flat" class="headerlink" title="数组常用方法补充reduce、filter、flat"></a>数组常用方法补充reduce、filter、flat</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/16%E3%80%81%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%A1%A5%E5%85%85reduce%E3%80%81filter%E3%80%81flat.png"></p><h4 id="Math的常用方法"><a href="#Math的常用方法" class="headerlink" title="Math的常用方法"></a>Math的常用方法</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/17%E3%80%81Math%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png"></p><h4 id="字符串中的常用方法"><a href="#字符串中的常用方法" class="headerlink" title="字符串中的常用方法"></a>字符串中的常用方法</h4><p><img src="https://gitee.com/jinsexiaozhima/jiujin/raw/master/Mindmap/%E5%8E%9F%E7%94%9FJS%E7%AF%87/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87/18%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png"></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">卓越科技-</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://blog.zykjofficial.top/posts/d3a7443d/">https://blog.zykjofficial.top/posts/d3a7443d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.zykjofficial.top" target="_blank">卓越科技的Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/javascriptstudy-cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/8cde864d/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/javascript-cover.png" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaScript高级</div></div></a></div><div class="next-post pull-right"><a href="/posts/4b2dadbc/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/cssstudy-cover.png" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CSS学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/d95a567b/" title="LeetCode算法题学习"><img class="cover" src="https://tva4.sinaimg.cn/large/9bd9b167gy1fwsi3fn92oj21hc0u07wi.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-02</div><div class="title">LeetCode算法题学习</div></div></a></div><div><a href="/posts/8cde864d/" title="JavaScript高级"><img class="cover" src="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/javascript-cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-02</div><div class="title">JavaScript高级</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-info__name">卓越科技-</div><div class="author-info__description">Remarkable life,for science and technology.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">JavaScript基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E6%A6%82%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">JS概论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">JS词法结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E6%B3%A8%E9%87%8A"><span class="toc-number">1.2.1.</span> <span class="toc-text">JS注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E7%9B%B8%E5%85%B3"><span class="toc-number">1.2.2.</span> <span class="toc-text">JS相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.2.3.</span> <span class="toc-text">JS命名规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E5%B5%8C%E5%85%A5HTML"><span class="toc-number">1.3.</span> <span class="toc-text">JS嵌入HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">行内式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">内联式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%81%94%E5%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">外联式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80"><span class="toc-number">1.3.4.</span> <span class="toc-text">指定脚本语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#script%E6%A0%87%E8%AE%B0%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.5.</span> <span class="toc-text">script标记的属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.</span> <span class="toc-text">JS输入输出语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.</span> <span class="toc-text">JS变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.5.1.</span> <span class="toc-text">声明和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">声明变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">变量的初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%AF%AD%E6%B3%95%E6%89%A9%E5%B1%95"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">变量语法扩展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">声明多个变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-number">1.5.1.6.</span> <span class="toc-text">声明变量的特殊情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">1.5.2.</span> <span class="toc-text">变量命名规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">作用域类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">全局变量和局部变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">全局对象和调用对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">作用域链</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.5.4.</span> <span class="toc-text">垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%90%8C"><span class="toc-number">1.6.</span> <span class="toc-text">数据类型(占用内存大小不同)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">简单数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">复杂数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%9E%8BNumber"><span class="toc-number">1.6.3.</span> <span class="toc-text">数字型Number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B-%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.4.</span> <span class="toc-text">字符串型(不是对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84length%E5%B1%9E%E6%80%A7"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">字符串的length属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">字符串拼接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-number">1.6.5.</span> <span class="toc-text">布尔型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">1.6.6.</span> <span class="toc-text">undefined</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-number">1.6.7.</span> <span class="toc-text">null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.8.</span> <span class="toc-text">数据类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E4%B8%BA%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-number">1.6.8.1.</span> <span class="toc-text">转为字符型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E4%B8%BA%E6%95%B0%E5%AD%97%E5%9E%8B-%E9%87%8D%E7%82%B9"><span class="toc-number">1.6.8.2.</span> <span class="toc-text">转为数字型(重点)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E6%8E%8C%E6%8F%A1"><span class="toc-number">1.6.8.3.</span> <span class="toc-text">重点掌握</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-number">1.6.8.4.</span> <span class="toc-text">转化为布尔型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.1.</span> <span class="toc-text">递增递减运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.2.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.3.</span> <span class="toc-text">instanceof运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8typeof%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.4.</span> <span class="toc-text">利用typeof获取变量数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.5.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.6.</span> <span class="toc-text">赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.8.</span> <span class="toc-text">语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.1.</span> <span class="toc-text">三种结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">顺序结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">分支结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">循环结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%9F%A5%E8%AF%86-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95"><span class="toc-number">1.8.2.</span> <span class="toc-text">小知识: 断点调试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.1.</span> <span class="toc-text">创建方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.9.2.</span> <span class="toc-text">数组的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.9.3.</span> <span class="toc-text">数组的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%A2%9E%E5%8A%A0"><span class="toc-number">1.9.4.</span> <span class="toc-text">数组元素增加</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.10.1.</span> <span class="toc-text">函数使用步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.10.2.</span> <span class="toc-text">函数的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.10.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arguments%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.10.4.</span> <span class="toc-text">arguments的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-number">1.10.5.</span> <span class="toc-text">小知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.6.</span> <span class="toc-text">函数的属性方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E7%9A%84%E9%A2%84%E8%A7%A3%E6%9E%90-%E5%B0%8F%E9%9A%BE%E7%82%B9-%E7%9C%8B%E6%A1%88%E4%BE%8B"><span class="toc-number">1.11.</span> <span class="toc-text">JS的预解析(小难点,看案例)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E5%BC%95%E6%93%8E%E8%BF%90%E8%A1%8C%E5%88%86%E4%B8%A4%E6%AD%A5"><span class="toc-number">1.11.1.</span> <span class="toc-text">js引擎运行分两步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E8%A7%A3%E6%9E%90%E5%88%86%E4%B8%BA"><span class="toc-number">1.11.2.</span> <span class="toc-text">预解析分为</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.</span> <span class="toc-text">JS的对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.1.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%94%B1%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E6%9E%84%E6%88%90"><span class="toc-number">1.12.2.</span> <span class="toc-text">对象由属性和方法构成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%B8%89%E7%A7%8D"><span class="toc-number">1.12.3.</span> <span class="toc-text">对象有三种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.4.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.5.</span> <span class="toc-text">遍历对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7"><span class="toc-number">1.12.6.</span> <span class="toc-text">删除属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AD%98%E5%9C%A8%E6%80%A7"><span class="toc-number">1.12.7.</span> <span class="toc-text">检查属性的存在性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.12.8.</span> <span class="toc-text">确定对象类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.9.</span> <span class="toc-text">序列化对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.10.</span> <span class="toc-text">内置对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.10.1.</span> <span class="toc-text">数学对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.10.2.</span> <span class="toc-text">日期对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.10.3.</span> <span class="toc-text">数组对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.10.4.</span> <span class="toc-text">字符串对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%92%8C%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.13.</span> <span class="toc-text">简单和复杂数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">1.13.1.</span> <span class="toc-text">简单数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">1.13.2.</span> <span class="toc-text">复杂数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88"><span class="toc-number">1.13.3.</span> <span class="toc-text">堆和栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E5%8F%82-%E4%BC%A0%E5%80%BC"><span class="toc-number">1.13.4.</span> <span class="toc-text">简单数据类型的传参(传值)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E5%8F%82-%E4%BC%A0%E5%9D%80"><span class="toc-number">1.13.5.</span> <span class="toc-text">复杂数据类型的传参(传址)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-APIs"><span class="toc-number">2.</span> <span class="toc-text">Web APIs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM"><span class="toc-number">2.1.</span> <span class="toc-text">DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.1.</span> <span class="toc-text">获取页面元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">事件概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.1.3.</span> <span class="toc-text">常见鼠标事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9-%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8E%E8%A1%A8%E5%8D%95"><span class="toc-number">2.1.4.</span> <span class="toc-text">改变元素内容(不适用于表单)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9"><span class="toc-number">2.1.5.</span> <span class="toc-text">改变表单元素内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E6%A0%B7%E5%BC%8F"><span class="toc-number">2.1.6.</span> <span class="toc-text">改变元素对象样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E5%A4%B1%E5%8E%BB%E7%84%A6%E7%82%B9"><span class="toc-number">2.1.7.</span> <span class="toc-text">获得失去焦点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E4%BB%96%E6%80%9D%E6%83%B3-%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.8.</span> <span class="toc-text">排他思想 (算法)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.9.</span> <span class="toc-text">获取自定义属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9"><span class="toc-number">2.1.10.</span> <span class="toc-text">节点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.10.1.</span> <span class="toc-text">节点的三个属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.10.2.</span> <span class="toc-text">父子节点操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.10.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.11.</span> <span class="toc-text">三种动态创建元素区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7"><span class="toc-number">2.2.</span> <span class="toc-text">事件高级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">注册事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">删除事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">事件流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.4.</span> <span class="toc-text">事件对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.5.</span> <span class="toc-text">常见事件对象的属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">2.2.6.</span> <span class="toc-text">事件委托</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.7.</span> <span class="toc-text">常用鼠标事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.8.</span> <span class="toc-text">常用键盘事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOM"><span class="toc-number">2.3.</span> <span class="toc-text">BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Window%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.3.1.</span> <span class="toc-text">Window常见事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.2.</span> <span class="toc-text">this指向问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97-%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81"><span class="toc-number">2.3.3.</span> <span class="toc-text">JS的执行队列(非常重要)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Location%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.4.</span> <span class="toc-text">Location对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Navigator%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.5.</span> <span class="toc-text">Navigator对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#History%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.6.</span> <span class="toc-text">History对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88-PC%E7%AB%AF"><span class="toc-number">2.4.</span> <span class="toc-text">网页特效-PC端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#offset%E7%B3%BB%E5%88%97"><span class="toc-number">2.4.1.</span> <span class="toc-text">offset系列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#offset%E7%B3%BB%E5%88%97%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">offset系列常用属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#offset%E4%B8%8Estyle%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">offset与style区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#client%E7%B3%BB%E5%88%97"><span class="toc-number">2.4.2.</span> <span class="toc-text">client系列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E4%B9%8BoffsetX-Y"><span class="toc-number">2.4.3.</span> <span class="toc-text">事件对象之offsetX&#x2F;Y</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.4.</span> <span class="toc-text">立即执行函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scroll%E7%B3%BB%E5%88%97"><span class="toc-number">2.4.5.</span> <span class="toc-text">scroll系列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.6.</span> <span class="toc-text">三大系列总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mouseover-mouseenter"><span class="toc-number">2.4.7.</span> <span class="toc-text">mouseover&#x2F;mouseenter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">动画函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81%E9%98%80"><span class="toc-number">2.6.</span> <span class="toc-text">节流阀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8"><span class="toc-number">2.7.</span> <span class="toc-text">客户端存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H5%E6%96%B0%E5%A2%9EAPI"><span class="toc-number">2.8.</span> <span class="toc-text">H5新增API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81"><span class="toc-number">2.8.1.</span> <span class="toc-text">检测网络连接状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.8.1.1.</span> <span class="toc-text">网络连接事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E8%B7%AF%E6%96%AD%E5%BC%80%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.8.1.2.</span> <span class="toc-text">网路断开事件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%8F%E6%98%BE%E7%A4%BA"><span class="toc-number">2.8.2.</span> <span class="toc-text">全屏显示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%85%A8%E5%B1%8F%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.8.2.1.</span> <span class="toc-text">请求全屏事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E5%85%A8%E5%B1%8F"><span class="toc-number">2.8.2.2.</span> <span class="toc-text">取消全屏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E5%85%A8%E5%B1%8F"><span class="toc-number">2.8.2.3.</span> <span class="toc-text">检测是否全屏</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-number">2.8.3.</span> <span class="toc-text">文件读取</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FileReader%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.8.3.1.</span> <span class="toc-text">FileReader对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">2.8.3.2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">2.8.3.3.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">2.8.3.4.</span> <span class="toc-text">事件处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#video%E6%A0%87%E7%AD%BE"><span class="toc-number">2.8.4.</span> <span class="toc-text">video标签</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">图解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-number">3.1.</span> <span class="toc-text">基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">3.1.1.</span> <span class="toc-text">前端发展史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text">认识浏览器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.3.</span> <span class="toc-text">JS 基础知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%B1%BB%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.4.</span> <span class="toc-text">三类输出方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#number%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.5.</span> <span class="toc-text">number数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.6.</span> <span class="toc-text">string数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#boolean%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.7.</span> <span class="toc-text">boolean数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.8.</span> <span class="toc-text">object数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E9%87%8C%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-number">3.1.9.</span> <span class="toc-text">条件判断里的相互转换规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98"><span class="toc-number">3.1.10.</span> <span class="toc-text">数据类型之间的区别(堆栈内存)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E4%B8%AD%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A4%E6%96%AD%E5%8F%8A%E5%88%A4%E6%96%AD%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%A3%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.11.</span> <span class="toc-text">JS中三种常见的判断及判断中常用的散知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E4%B8%AD%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A4%E6%96%AD%E5%8F%8A%E5%88%A4%E6%96%AD%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%A3%E7%9F%A5%E8%AF%86-1"><span class="toc-number">3.1.12.</span> <span class="toc-text">JS中三种常见的判断及判断中常用的散知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%85%A8%EF%BC%89"><span class="toc-number">3.1.13.</span> <span class="toc-text">函数基础知识（全）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.14.</span> <span class="toc-text">数组的基础知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.15.</span> <span class="toc-text">数组中的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%A1%A5%E5%85%85reduce%E3%80%81filter%E3%80%81flat"><span class="toc-number">3.1.16.</span> <span class="toc-text">数组常用方法补充reduce、filter、flat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.17.</span> <span class="toc-text">Math的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.18.</span> <span class="toc-text">字符串中的常用方法</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/7305059/" title="Vue3学习"><img src="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/vuestudy-cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Vue3学习"></a><div class="content"><a class="title" href="/posts/7305059/" title="Vue3学习">Vue3学习</a><time datetime="2020-10-21T01:37:56.000Z" title="发表于 2020-10-21 09:37:56">2020-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/93afb348/" title="基于Butterfly主题添加Artalk评论系统"><img src="https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/img/addartalk-cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="基于Butterfly主题添加Artalk评论系统"></a><div class="content"><a class="title" href="/posts/93afb348/" title="基于Butterfly主题添加Artalk评论系统">基于Butterfly主题添加Artalk评论系统</a><time datetime="2020-09-21T08:17:59.000Z" title="发表于 2020-09-21 16:17:59">2020-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/69742e4c/" title="Python学习"><img src="https://tva4.sinaimg.cn/large/9bd9b167gy1g4lhihs5ayj21hc0xc4cx.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Python学习"></a><div class="content"><a class="title" href="/posts/69742e4c/" title="Python学习">Python学习</a><time datetime="2020-09-07T00:32:26.000Z" title="发表于 2020-09-07 08:32:26">2020-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d95a567b/" title="LeetCode算法题学习"><img src="https://tva4.sinaimg.cn/large/9bd9b167gy1fwsi3fn92oj21hc0u07wi.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LeetCode算法题学习"></a><div class="content"><a class="title" href="/posts/d95a567b/" title="LeetCode算法题学习">LeetCode算法题学习</a><time datetime="2020-09-02T01:08:40.000Z" title="发表于 2020-09-02 09:08:40">2020-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bbacf423/" title="Websocket学习"><img src="https://tva4.sinaimg.cn/large/9bd9b167ly1fwsfqurogcj21hc0u01kx.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Websocket学习"></a><div class="content"><a class="title" href="/posts/bbacf423/" title="Websocket学习">Websocket学习</a><time datetime="2020-08-24T08:34:24.000Z" title="发表于 2020-08-24 16:34:24">2020-08-24</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By 卓越科技-</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>